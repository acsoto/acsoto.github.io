{"pages":[{"title":"Photo","text":"","link":"/photo/index.html"},{"title":"github","text":"","link":"/github/index.html"},{"title":"Video","text":"","link":"/video/index.html"},{"title":"friends","text":"FRIENDSCharlot’s Blog cetlewa","link":"/friends/index.html"}],"posts":[{"title":"AC又被黑了","text":"下午突然看到服务器有人发 仔细一看 打开链接一看： 很无语，一开始以为是国外作案，黑进数据库了，一看我数据库根本没对外网开放 查来查去发现是有人盗了一个用来处理封禁的账号，进去之后一通乱封 把数据库恢复了一下备份，玩家还是进不去，我能进去，查了一下litebans的官网，是用了一个封锁服务器进入权限的指令，打了个指令就解决了。 很低级的手段，很无聊的恶趣味 后续原本晚上前往教学楼复习数分，没有带电脑。 没想到，在傍晚又被黑了，因为只是还有管理号没有停掉，仅凭手机暂时解决了问题，在仔细推敲后，认为其是通过非法调用我部署在web服务器的litebans端的api来实现用拥有权限的玩家账号去封禁其他玩家。 结果在稍晚一点又一次被黑，终于意识到，事情根本没有那么复杂，只是因为litebans是BC插件，Authme没办法限制登陆前对指令使用权限，任意一个有litebans权限的账号都在未登陆的情况下可以随意使用指令。其实早就应该发现我留了这种低级漏洞的，也没想道竟然这么久了才有人发现了这个这么简单的漏洞。","link":"/posts/57464/"},{"title":"IoTMonitor","text":"IoTMonitor用于展示IoT课程开发板的相关信息并进行控制 可以通过调用我们部署的服务器api及时获取开发板的温湿度数据，也可以发送开关电机的指令，并且可以设置温湿度超过某阈值后报警，同时有历史记录来提供任意时间段内好看的温湿度曲线 图片 简介主页面分为三个部分：设备状态，历史记录，设置 UI整体使用卡片式扁平设计 设备状态刷新按钮和更新温湿度数据，温湿度可以显示此时设备的温湿度传感器信息，打开电机和关闭电机功能用于控制控制板马达 其中，温湿度会每秒自动进行更新，2位小数点保留 历史记录通过DatePicker选择起止时间，再点击获取，即可得到此段时间内的温湿度曲线，触摸曲线还可以动态显示任意一点的数值（此处使用了ChartView库） 默认显示2天前到现在的曲线，第一次打开app时会同步一次 设置在设置页面，通过选择器选择阈值后点击保存，当温度高于此阈值时，开发板电机将会转动 同时，打开app后每次阈值的设置会被记录，以便查看设置情况 功能 实时显示开发板传感器温湿度 实时控制开发板电机马达转动与否 获取任意时间段开发板传感器温湿度历史曲线 通过设置过热阈值，当温度超过此值，进行报警 后台实时更新 实现该app主要通过HTTP GET和POST请求像我们的服务器后端发送请求，后端通过电信平台的api调用来发送相关指令，电信平台再把指令下达到开发板，来实现app与开发板的交互 该app的UI其中一部分复用了我之前的项目Memo的代码","link":"/posts/1970/"},{"title":"Alxa_Compiler 编译器","text":"相关文章：[[编译实验总结感想]] 词法分析Before CodeRequriement: read testfile.txt, parse every char to word and print them. At the same time, memorize type, content and line number of each word. File readingRead by line, scan every char of every string and analyse. 123while ((s = bf.readLine()) != null) { ...} AnalyseWhen i get the key word, enter the next analyst. 1234567891011121314151617181920212223while ((c = getChar()) != null) { if (c == ' ' || c == '\\r' || c == '\\t') { continue; } else if (c == '+' || c == '-' || c == '*' || c == '%') { words.add(new Word(c)); } else if (c == '/') { analyseSlash(); } else if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}') { words.add(new Word(c)); } else if (c == '&gt;' || c == '&lt;' || c == '=' || c == '!') { analyseRelation(c); } else if (c == ',' || c == ';') { words.add(new Word(c)); } else if (c == '&quot;') { analyseCitation(); } else if (c == '&amp;' || c == '|') { analyseLogic(c); } else if (Character.isDigit(c)) { analyseDigit(c); } else if (Character.isLetter(c) || c == '_') { analyseLetter(c); }} CommonFor example, when I get ‘+’, I directly new a Word typify the “PLUS”. FunctionFor example When I get &lt; , enter functionanalyseRelation read one char more. If it is=, analyze LEQ… 12345678if (c == '&lt;') { c = getChar(); if (c == '=') { words.add(new Word(&quot;&lt;=&quot;)); } else { unGetChar(); words.add(new Word(&quot;&lt;&quot;)); } analyseLogic is as the same. Digit and LetterDigit: When I get a digit, it means I will scan a serial of some digits and turn them into a Word typify “INTCON”. Letter: When I get a letter, it means I will scan a string about letter or digit. It maybe a “IDENFR” or “STRCON”, which depends on whether it is in key map or not. Wordclass Word: 12345public class Word { private String identification; private String content; private String type;} Capsulate the initial function, I only need to new Word(...) in the main processor, which will create the corresponding word. For example 12345public Word(char identification) { this.identification = String.valueOf(identification); this.type = new KeyWordMap().getType(this.identification); this.content = this.identification;} As for KeyWordMap, it is a HashMap, mapping the string of word and its type. 1234567public KeyWordMap() { keyWords = new HashMap&lt;&gt;(); keyWords.put(&quot;main&quot;, &quot;MAINTK&quot;); keyWords.put(&quot;const&quot;, &quot;CONSTTK&quot;); keyWords.put(&quot;int&quot;, &quot;INTTK&quot;); ... } After CodeFile readingRead file by line is not convenient for preread and undo, so I read the file into a single String at first. The method is read by line, add \\n after every line and scan every char. When I get \\n, lineNum++ 123456789private String transferFileToCode() { BufferedReader bf = new BufferedReader(reader); StringBuffer buffer = new StringBuffer(); String s = null; while ((s = bf.readLine()) != null) { buffer.append(s).append(&quot;\\n&quot;); } return buffer.toString();} AnalyseAbout analyst, it is different from what before coding. First, I need analyze word one by one, so I add global variety index to memorize where is the pointer. Besides, I met the situation that I need read one more or undo, so I encapsulate the function ungetChar and getChar, which will be convenient for me to analyze. 1234567891011121314151617181920private Character getChar() { if (index &lt; code.length()) { char c = code.charAt(index); if (c == '\\n') { lineNum++; } index++; return c; } else { return null; }}private void unGetChar() { index--; char c = code.charAt(index); if (c == '\\n') { lineNum--; }} Slash // : When it comes to \\n , stop. 1234567do { c = getChar(); if (c == null || c == '\\n') { return; // 判断为//注释，结束分析 }} while (true); /* */: Get char until */ appears 123456789101112131415do { c = getChar(); if (c == null) { return; } if (c == '*') { c = getChar(); if (c == '/') { return; // 判断为/* */注释，直接结束分析 } else { unGetChar(); } }} while (true); 语法分析Requirement: Based on the words identified by the lexical analysis program, identify various grammatical elements according to the grammatical rules. Recursive descent method is used to analyze the grammatical components defined in the grammar. Before CodeData ReadingLike the lexical analyst, I prepared function getWord getNextWord and so on. At the same time, there is a global variety (Word) curWord to display which word it is when I read ArrayList&lt;Word&gt; words from lexical analyst one by one. My analyst tragedy is as follows: To normal rule: I keep getting words and analyze them To expression rule: I scan the whole expression first, which is implemented by function getExp. Then I divide the expression and use method recursive descent to analyze them. getExp like 12345678910111213private ArrayList&lt;Word&gt; getExp() { ArrayList&lt;Word&gt; exp = new ArrayList&lt;&gt;(); while (true) { if (word is symbol of end) { break; } ... getWordWithoutAddToGrammar(); exp.add(curWord); word = getNextWord(); } return exp;} recursive descentAccording to Grammatical Rules, code function for every term of rule. Main idea: read a word, check what it symbolize and enter the next analyzing function. For example: to 1CompUnit → {Decl} {FuncDef} MainFuncDef // 1.是否存在Decl 2.是否存在 FuncDef I analyze like this: 12345678910111213141516171819private void analyseCompUnit() { Word word = getNextWord(); while (word.typeEquals(&quot;CONSTTK&quot;) || ( word.typeEquals(&quot;INTTK&quot;) &amp;&amp; getNext2Word().typeEquals(&quot;IDENFR&quot;) &amp;&amp; !getNext3Word().typeEquals(&quot;LPARENT&quot;))) { analyseDecl(); word = getNextWord(); } while (word.typeEquals(&quot;VOIDTK&quot;) || ( (word.typeEquals(&quot;INTTK&quot;) &amp;&amp; !getNext2Word().typeEquals(&quot;MAINTK&quot;)))) { analyseFuncDef(); word = getNextWord(); } if (word.typeEquals(&quot;INTTK&quot;) &amp;&amp; getNext2Word().typeEquals(&quot;MAINTK&quot;)) { analyseMainFuncDef(); } else { error(); } grammar.add(&quot;&lt;CompUnit&gt;&quot;);} grammar is used for memorize output of lexical analyst and grammar analyst list. left recursion1加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 Check if the exp has ‘+’ or ‘-‘. If it has, separate the exp to AddExp and MulExp. Then analyze them separately. After Codeleft recursionThe method used before is not perfect for recursive descent. So I changed my rewrite way. to 1加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 Rewrite it like 1AddExp → MulExp ('+' | '−') MulExp ('+' | '−') MulExp ... Code like 1234567891011private void analyseMulExp(ArrayList&lt;Word&gt; exp) { Exps exps = divideExp(exp, new ArrayList&lt;&gt;(Arrays.asList(&quot;MULT&quot;, &quot;DIV&quot;, &quot;MOD&quot;))); int j = 0; for (ArrayList&lt;Word&gt; exp1 : exps.getWords()) { analyseUnaryExp(exp1); grammar.add(&quot;&lt;MulExp&gt;&quot;); if (j &lt; exps.getSymbols().size()) { grammar.add(exps.getSymbols().get(j++).toString()); } }} Function divideExp is used for divide the whole exp passed by getExp or the pre function. divideExp: In: orignal: exp stop symbol: symbol Out: List of divided exp and symbol. 12345678910111213141516171819202122232425262728293031323334353637383940private Exps divideExp(ArrayList&lt;Word&gt; exp, ArrayList&lt;String&gt; symbol) { ArrayList&lt;ArrayList&lt;Word&gt;&gt; exps = new ArrayList&lt;&gt;(); ArrayList&lt;Word&gt; exp1 = new ArrayList&lt;&gt;(); ArrayList&lt;Word&gt; symbols = new ArrayList&lt;&gt;(); boolean unaryFlag = false; int flag1 = 0; int flag2 = 0; for (int i = 0; i &lt; exp.size(); i++) { Word word = exp.get(i); if (word.typeEquals(&quot;LPARENT&quot;)) { flag1++; } if (word.typeEquals(&quot;RPARENT&quot;)) { flag1--; } if (word.typeEquals(&quot;LBRACK&quot;)) { flag2++; } if (word.typeEquals(&quot;RBRACK&quot;)) { flag2--; } if (symbol.contains(word.getType()) &amp;&amp; flag1 == 0 &amp;&amp; flag2 == 0) { //UnaryOp if (word.typeOfUnary()) { if (!unaryFlag) { exp1.add(word); continue; } } exps.add(exp1); symbols.add(word); exp1 = new ArrayList&lt;&gt;(); } else { exp1.add(word); } unaryFlag = word.typeEquals(&quot;IDENFR&quot;) || word.typeEquals(&quot;RPARENT&quot;) || word.typeEquals(&quot;INTCON&quot;) || word.typeEquals(&quot;RBRACK&quot;); } exps.add(exp1); return new Exps(exps, symbols);} Exps 1234public class Exps { private ArrayList&lt;ArrayList&lt;Word&gt;&gt; words; private ArrayList&lt;Word&gt; symbols;} other bugsMost bugs are produced by function getExp and divideExp because of some situations are ignored. So I always get something like index out of range… So I changed some symbol of stop getting expression and modify the rules to divide or not the expression and so on. 错误处理Before CodeCreate the symbol tableSymbol class 123456public class Symbol { private String type; private int intType; private String content; private int area = 0;} Type means the type of the symbol. IntType is an integer. If it’s 0, the symbol is int. if it’s 1, the symbol is int[], if it’s 2, the symbol is int[] []… Content is its content. Area is where is it. I create a HashMap of Symbols, memorizing symbols created in each area. When I enter a new area, area++. When I leave an area, area–, with the corresponding Symbols are destroyed. 123456private HashMap&lt;Integer, Symbols&gt; symbols = new HashMap&lt;&gt;();private HashMap&lt;String, Function&gt; functions = new HashMap&lt;&gt;();private ArrayList&lt;Error&gt; errors = new ArrayList&lt;&gt;();private int area = -1;private boolean needReturn = false;private int whileFlag = 0; needReturn means if the current function need to return. whileFlag means if the current code block is in while circle. ErrorsaJust check format 12345678910111213141516public boolean isFormatIllegal() { for (int i = 1; i &lt; content.length() - 1; i++) { char c = content.charAt(i); if (!isLegal(c)) { if (c == '%' &amp;&amp; content.charAt(i + 1) == 'd') { continue; } return true; } else { if (c == '\\\\' &amp;&amp; content.charAt(i + 1) != 'n') { return true; } } } return false;} b cB: Every time I get an identity, check if there is the same symbol has been defined in this area. 123private boolean hasSymbolInThisArea(Word word) { return symbols.get(area).hasSymbol(word);} C: Check all area. If the symbol has been defined. Functions are as the same. 12345678private boolean hasSymbol(Word word) { for (Symbols s : symbols.values()) { if (s.hasSymbol(word)) { return true; } } return false;} d eTo check if the function parameters are matched, I memorize parameters of every function and when I met a function call, I will scan the function call parameters and match them. I prepare a function to do this. Finally I found I need to use recursive descent again, so I add the check procedure to the recursive descent of the grammatical analyst. Please check the After Code/Error d and e f gThere is a global variety needReturn used to display if the current function need return. if it does but there is no return in the end of the code block, or if it doesn’t but there is return, the error will be memorized. hJust check if it is a const. 123if (isConst(word)) { error(&quot;h&quot;, word.getLineNum());} i j kCapsulate function about checking missing of the symbol For example: 1234567private void checkParent() { if (getNextWord().typeEquals(&quot;RPARENT&quot;)) { getWord();// ) } else { error(&quot;j&quot;); }} lCount the number of the parameters of string and printf separately and check if they equal. mThere is a global variety whileFlag symbolize if the code block is in while circle. If it isn’t, any continue and break will produce error. After CodeAreaI mark the area++ when I get a block or a function, but it will lead to the situation that when enter a code block of a function, the parameters of the function can’t be memorize in the different are with the block of the function. So I changed the rules to mark area++. 1234567private boolean analyseBlock(boolean fromFunc) { ... if (!fromFunc) { addArea(); } ...} Only when the block is not from the function, the area++. Error d and eTo check if the function parameters are matched, I set an array for every function. 123456public class Function { private String type; private String content; private String returnType; private ArrayList&lt;Integer&gt; paras;} When I get a function, I memorize its return type and paras. As for the ArrayList&lt;Integer&gt; paras, it reflects as follows: Type Example Integer Void -1 Int a 0 Int[] a[] 1 Int[] [] a[] [3] 2 So when I get a function call, I will check the parameter of it with what I have memorized before. 1234567891011private void checkParasMatchRParas(Word ident, ArrayList&lt;Integer&gt; paras, ArrayList&lt;Integer&gt; rparas) { if (paras.size() != rparas.size()) { error(&quot;d&quot;, ident.getLineNum()); } else { for (int i = 0; i &lt; paras.size(); i++) { if (!paras.get(i).equals(rparas.get(i))) { error(&quot;e&quot;, ident.getLineNum()); } } }} As for getting the parameters real type, I add the analyst procedure to the recursive descent of the grammatical analyst. Just like: 12345private int analyseExp(ArrayList&lt;Word&gt; exp) { int intType = analyseAddExp(exp); grammar.add(&quot;&lt;Exp&gt;&quot;); return intType;} Every recursion will return an intType, which symbolize the final type of the expression. Because the terms of one expression must be the same type, so I return only one of them. This is the exit of the recursion. It will return a correct type of the expression to the top of the function. 1234567891011121314private int analyseLVal(ArrayList&lt;Word&gt; exp) { int intType = 0; ... if (word.typeEquals(&quot;LBRACK&quot;)) { intType++; ... } ... if (hasSymbol(ident)) { return getSymbol(ident).getIntType() - intType; } else { return 0; }} 代码生成In this part, I chose to generate Pcode. I designed a type of Pcode which is an Inverse Bolan expression stack and symbol table based virtual code. At the same time, I designed virtual machine to execute them. The Pcode virtual machine is an imaginary machine used to run Pcode commands. It consists of: A code area (code), an instruction pointer (EIP), a stack, a var_table, a func_table and a label_table. In the following passage, I will introduce how Pcode executes first and how to produce Pcode next. Before CodeHow does the virtual machine runFirst, we need a codes list and a stack(int). An eip: presents the address of current running code. A varTable: memorizes the address of the variety in stack. A funcTable: memorizes the address of the function in codes list. A labelTable: Memorizes the address of the label in codes list. Then, run the code one after another and manage the stack. How to distinguish different varietyBefore generate codes, differentiate varieties from different scopes by its only scope number, like: areaID + &quot;_&quot; + curWord.getContent(). In this situation, the variety will not appear more than once in codes, except for recursive function call, which will be solved by push varTable to stack(show later). Specific Code DefinitionFirst, define a class for PCode: 12345public class PCode { private CodeType type; private Object value1 = null; private Object value2 = null;} It presents one code object, which has a CodeType and two operating values. CodeType is an enum. Value1 and value2 maybe Integer or String or null, which depends on specific code type. Calculation TypeTwo operators: 123int b = pop();int a = pop();push(cal(a,b)); Single operator: 1push(cal(pop())); VARVAR command to declare a variable, save the variable name and the address assigned to it in the variable table. 1234case VAR: { Var var = new Var(stack.size()); varTable.put((String) code.getValue1(), var);} Var.class: 123456public class Var { private int index; private int dimension = 0; private int dim1; private int dim2;} DIMVARDIMVAR command to declare an array. Set the dimension information of the var. 1234567891011121314case DIMVAR: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); var.setDimension(n); if (n == 1) { int i = pop(); var.setDim1(i); } if (n == 2) { int j = pop(), i = pop(); var.setDim1(i); var.setDim2(j); }} PLACEHOLDERPLACEHOLDER command to grow the stack down, allocate the new space to the variety and array. 1234567891011121314151617case PLACEHOLDER: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); if (n == 0) { push(0); } if (n == 1) { for (int i = 0; i &lt; var.getDim1(); i++) { push(0); } } if (n == 2) { for (int i = 0; i &lt; var.getDim1() * var.getDim2(); i++) { push(0); } }} OtherCalculation type: pop the stack top once or twice, calculate them and push again. Jump Type: When it’s command about jump, just check if the condition is satisfied and change the eip. Function call: as follows Function call procedureFirst, before function call, there will be some parameters to be pushed into the stack. Each will be followed by a RPARA command, which memorize the address of the previous variety. 12345678case RPARA: { int n = (int) code.getValue1(); if (n == 0) { rparas.add(stack.size() - 1); } else { rparas.add(stack.get(stack.size() - 1)); }} Second, function CALL. Memorize the eip, stack top address, and information about the function(In fact, they will be pushed into stack too). Then update the varTable and eip. Ready for execute function. 12345678case CALL: { Func func = funcTable.get((String) code.getValue1()); retInfos.add(new RetInfo(eip, varTable, stack.size() - 1, func.getArgs(), func.getArgs(), nowArgsNum)); eip = func.getIndex(); varTable = new HashMap&lt;&gt;(); callArgsNum = func.getArgs(); nowArgsNum = 0;} Finally, return when it’s RET Restore eip, varTable from RetInfo, clear the new information pushed when function in the stack. 12345678910111213case RET: { int n = (int) code.getValue1(); RetInfo info = retInfos.remove(retInfos.size() - 1); eip = info.getEip(); varTable = info.getVarTable(); callArgsNum = info.getCallArgsNum(); nowArgsNum = info.getNowArgsNum(); if (n == 1) { stack.subList(info.getStackPtr() + 1 - info.getParaNum(), stack.size() - 1).clear(); } else { stack.subList(info.getStackPtr() + 1 - info.getParaNum(), stack.size()).clear(); }} Value or AddressPush value or address of the variety is an important thing, it depends on what I need, which will be presented when I describe how to generate codes. The command action is as follows(getAddress is used for get the address of the previous variety ). 12345678910111213case VALUE: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); int address = getAddress(var, n); push(stack.get(address));}...case ADDRESS: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); int address = getAddress(var, n); push(address);} Code GenerateCode generated from the grammatical analyst procedure. DeclarationThere is no need to distinguish const and var. When declare a variety, just new a variety and let it point to the stack top. Then if it has an initialization, just push the values one after another. If not, add a PLACEHOLDER command to push something(I push 0) to the stack to hold the place. Assign sentenceIn this situation, first calculate and push the address of the variety to the stack top. Then analyze expressions. After that, there are only two number in the stack, which are address and value. Assign the value to the address. Condition control sentenceFirst, generate labels. Then, place jump sentences in the proper places. labels about if and while will be generated and then stored in a stack type structure. like: 1234whileLabels.add(new HashMap&lt;&gt;());whileLabels.get(whileLabels.size() - 1).put(&quot;while&quot;, labelGenerator.getLabel(&quot;while&quot;));whileLabels.get(whileLabels.size() - 1).put(&quot;while_end&quot;, labelGenerator.getLabel(&quot;while_end&quot;));whileLabels.get(whileLabels.size() - 1).put(&quot;while_block&quot;, labelGenerator.getLabel(&quot;while_block&quot;)); Take if as example: 12345678910111213141516if (word.typeEquals(&quot;IFTK&quot;)) { codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(&quot;if&quot;))); ... analyseCond(&quot;IFTK&quot;); ... codes.add(new PCode(CodeType.JZ, ifLabels.get(ifLabels.size() - 1).get(&quot;else&quot;))); codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(&quot;if_block&quot;))); analyseStmt(); codes.add(new PCode(CodeType.JMP, ifLabels.get(ifLabels.size() - 1).get(&quot;if_end&quot;))); codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(&quot;else&quot;))); if (word.typeEquals(&quot;ELSETK&quot;)) { getWord(); //else analyseStmt(); } codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(&quot;if_end&quot;)));} while: 12345678910111213141516171819202122232425262728if (word.typeEquals(&quot;WHILETK&quot;)) { ... codes.add(new PCode(CodeType.LABEL, whileLabels.get(whileLabels.size() - 1).get(&quot;while&quot;))); ... analyseCond(&quot;WHILETK&quot;); ... codes.add(new PCode(CodeType.JZ, whileLabels.get(whileLabels.size() - 1).get(&quot;while_end&quot;))); codes.add(new PCode(CodeType.LABEL, whileLabels.get(whileLabels.size() - 1).get(&quot;while_block&quot;))); analyseStmt(); ... codes.add(new PCode(CodeType.JMP, whileLabels.get(whileLabels.size() - 1).get(&quot;while&quot;))); codes.add(new PCode(CodeType.LABEL, whileLabels.get(whileLabels.size() - 1).get(&quot;while_end&quot;))); whileLabels.remove(whileLabels.size() - 1);}// breakif (word.typeEquals(&quot;BREAKTK&quot;)) { getWord();//break codes.add(new PCode(CodeType.JMP, whileLabels.get(whileLabels.size() - 1).get(&quot;while_end&quot;))); ...}// continueif (word.typeEquals(&quot;CONTINUETK&quot;)) { getWord();//continue codes.add(new PCode(CodeType.JMP, whileLabels.get(whileLabels.size() - 1).get(&quot;while&quot;))); ...} After CodeBecause of some runtime errors and information shortages, I added and removed some Pcode. At the same, there are some new troubles about address pass and short circuit calculation. Specific Code DefinitionIn Operation, push() means put value into the top of the stack. pop() means pop the value from the top of the stack. Common Type CodeType Value1 Value2 Operation LABEL Label_name Set a label VAR Ident_name Declare a variety PUSH Ident_name/Digit push(value1) POP Address Ident_name *value1 = value2 JZ Label_name Jump if stack top is zero JNZ Label_name Jump if stack top is not zero JMP Label_name Jump unconditionally MAIN Main function label FUNC Function label ENDFUNC End of function label PARA Ident_name Type Parameters RET Return value or not Function return CALL Function name Function call RPARA Type Get parameters ready for function call GETINT Get a integer and put it into stack top PRINT String Para num Pop values and print. DIMVAR Ident_name Type Set dimension info for array variety VALUE Ident_name Type Get the variety value ADDRESS Ident_name Type Get the variety address PLACEHOLDER Push something to hold places EXIT Exit CodeType Value1 Value2 Operation ADD + SUB - MUL * DIV / MOD % CMPEQ == CMPNE != CMPGT &gt; CMPLT &lt; CMPGE &gt;= CMPLE &lt;= AND &amp;&amp; OR || NOT ! NEG - POS + short circuit calculationThere are two situations I need to use short circuit calculation : 121. if(a&amp;&amp;b) // a is false2. if(a||b) // b is true This seems not an easy thing and I acutally spent lots of time to solve it. My method is as follows: First, when I analyze analyseLOrExp, every analyseLAndExp will be followed by a JNZ, which is used for detect if the cond is false. If it is, jump to the if body label. At the same time, I generated cond label, which is ready for the analyseLAndExp. 12345678910111213141516171819private void analyseLOrExp(ArrayList&lt;Word&gt; exp, String from) { ... for (...) { ... String label = labelGenerator.getLabel(&quot;cond_&quot; + i); analyseLAndExp(exp1, from, label); codes.add(new PCode(CodeType.LABEL, label)); if (...) { codes.add(new PCode(CodeType.OR)); } if (...) { if (...) { codes.add(new PCode(CodeType.JNZ, ifLabels.get(ifLabels.size() - 1).get(&quot;if_block&quot;))); } ... } ... }} In the analyseLAndExp, every analyseEqExp will be followed by a JZ, which is used for detect if the cond is true. If it is, jump to the cond label I set just now. 12345678910111213141516private void analyseLAndExp(ArrayList&lt;Word&gt; exp, String from, String label) { ... for (...) { ... analyseEqExp(exp1); if (...) { codes.add(new PCode(CodeType.AND)); } if (...) { if (...) { codes.add(new PCode(CodeType.JZ, label)); } ... } }} By these means, short circuit calculation is solved. 总结感想[[编译实验总结感想]]","link":"/posts/51052/"},{"title":"与鸟巢的匆匆一面","text":"今赴一场蓄谋已久的生日宴会，开场一个半小时后先行撤退且不辞而别，在此先把责任全部归咎于我自己，母上也对我的行为直呼无趣，倒也不是自讨没趣，只是封校许久难得有机会出来，想要自行去溜达一圈。 我在乘车前往目的地的路上，看到鸟巢灯火通明的一瞬间，突然感到与繁景告别已久（一个多月），仿佛自己离开了这个城市。恍然间审视起来自己这一个月真的是在有意义的活着吗？貌似是陷在编译里面虚度时间。忽然想起那句：北航人是没有生活的(链接)，直呼赞同。故在按部就班完成生日的惊喜后按耐不住，感觉在座的各位都有自己在这一场聚会中想要做的事情，我不甚相融其中，只想奔赴鸟巢，而且还有点饿，想吃点告别已久的，学校外边的食物，遂离开。 奔赴鸟巢并不顺利，沿湖东路莫名被封，我四处绕路，路上遇见几位也是如此，最后还是从东侧大道进入，赶在闭园的前几分钟，好心的保安提示我赶紧进去，进去后反倒不如在湖边拍下的风景好，中轴线的人也不多，只有几个年轻人还在滑滑板，却也算完成了今日的心愿。 见到倒计时板只剩下76天，想到第一次来这个地方，已相隔七百来天，不甚感慨，在BUAA的这两年，在北京的这两年。 离开之际，地铁口附近有一些劲爆的音乐和放纵的，各个年龄段的朝阳群众正在狂欢。待了一会儿，离开了，也没吃到饭。（回BUAA吃了难吃的烤冷面和土豆）","link":"/posts/22522/"},{"title":"我的GitHub数据","text":"","link":"/posts/46556/"},{"title":"我的语言使用统计","text":"","link":"/posts/63393/"},{"title":"推歌 第一期","text":"uu们最近给我推的歌大家一起分享 カンタレラgrace edition 这首的交响版本也很棒： ODDTAXI 魂之轮回 HB to 剑风 魂のルフラン (魂之轮回) イナヅマ侍 旅行","link":"/posts/3151/"},{"title":"推歌 第二期","text":"uu们最近给我推的歌大家一起分享 YOASOBI新专辑 稚名林檎","link":"/posts/34886/"},{"title":"数学分析","text":"1 考完了，nmd难死了 数列极限 定义 Stolz 单调有界 函数极限 定义 连续 无穷大 无穷小 等价无穷小 1的无穷次 $e^{…}$ 一致连续 证明 $|f(x_1)-f(x_2)| &lt; A |x_1-x_2|$ $arctanx$与中值定理 导数 隐函数求导 参数方程求导 $\\frac{dy}{dx} = \\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}$ 高阶导数 莱布尼兹公式 $(uv)^n = \\sum_{k=0}^nu^{(n-k)}v^{k}$ 微分中值定理 罗尔中值定理 拉格朗日中值定理 函数性质 洛必达 泰勒公式 微分 Taylor公式 Peano余项 Lagrange余项","link":"/posts/51660/"},{"title":"泳社约游群的有趣见闻","text":"想来自己第一次跟着泳社学游泳到现在已经2年了，当初教我的人大多都已经毕业了。","link":"/posts/15362/"},{"title":"新北老年活动中心","text":"新北区迷惑大赏我真的不理解为什么他们喜欢在这片区域晒太阳和带小孩 上个学期上早八吃早饭，总会有一群阿姨比我更早，我不知道他们着不着急，反正我很着急 新的乒乓球桌也理所应当的成为了他们的活动设施 合一又是另一回事，属于是中小学食堂了","link":"/posts/31296/"},{"title":"BUAAOO-第一单元总结","text":"BUAAOO-第一单元总结基于度量分析程序结构第一次作业对多项式的求导，Expression类表示一个表达式，其成员变量为Term对象的hashmap，Interpreter用于解析输入字符串，返回一个Expression (1) 基于度量分析类复杂度 方法复杂度 可以看到Term.toString过于复杂，原因是在幂函数转化为string类型时使用了过多的if，此处可以进行优化。 本次作业没有被其他同学hack。性能方面，由于使用了hashmap，表达式基本上达到了最短，没有考虑到正负号打头和x**2拆分为x*x等细节 本次作业没有很好的给下一次作业做好铺垫，表达式解析方法过于粗暴。 第二次作业本次作业难度骤升，因为要考虑表达式因子，第一次作业使用的暴力解析字符串方法骤然失效，遂彻底进行重构。我在本次作业中大量时间用于研究如何递归下降读取表达式。求导本身并不困难，创建Factor接口，sin，cos，幂函数，常量，term，poly均继承Factor，保证每个因子都有实现tostring和求导以及simplify方法。其中，Term是一些Factor构成的List，Poly是一些Term构成的List。在对Poly进行求导会自然向下递归。 Patterns存放了提前编译好的正则表达式 Parser用于递归下降解析表达式 类复杂度 可见Parser中方法复杂度较高，这是因为在解析字符串过程中，我调用了过多的私有方法，此处可以进行模块化优化。 Term中由于simplify和diff的操作过于复杂，整体复杂度较高，此处可以把一些操作在初始化term时完成来优化。 方法复杂度 复杂度较高的几个方法 其中Term的simplify如前文所述，该方法过于臃肿。 第三次作业本次作业加入了sin和cos内的嵌套已经wrong format的检测。由于和上一次作业的架构相似，仅需调整sin和cos内成员变量为Poly，并且对parser进行进一步递归下降即可。wrong format成为了难点，由于上一次作业的递归下降读取基于表达式正确的情况，这次由于格式可能的错误，我对parser进行了较大的调整，首先对字符串进行多余空白符和非法字符的判断，随后在递归下降读取过程中判断格式错误，包括括号和幂函数的错误。 结构与第二次作业相似，加入了format checker和WF exception 类复杂度 方法复杂度 其中较高的和第二次作业类似 其中getCosFactor和getSinFactor是由于进行了格式的判断，此处重用了相似的代码，可以归类为一个方法进行优化。 分析自己程序的bug在前两次作业中，互测阶段没有被找到bug，在个人初期写代码过程中，遇到的一些BUG如：没有及时在while循环中continue，在if判断中逻辑过于复杂导致自己搞错了与或非逻辑，往往正是这类小的失误导致耗费大量时间debug，因此在写程序过程中应该时刻关注代码的复杂度。 第三次作业，互测阶段被hack了两次，问题均是出在格式判断正负号和常数之间的空格时，我的判断条件出了问题，误判了一些正确的格式，自己写wrong format时没有考虑到各种情况，测试不够充分。 对比分析出现bug的方法和未出现bug的方法在代码行和圈复杂度上的差异：在我的前两次作业中自己发生的BUG很明显主要是因为圈复杂度导致的，在第三次作业被hack的这个BUG主要是因为Wrong Format欠考虑。 分析自己发现别人程序bug采用策略主要采取的策略构建一些我在写代码过程中遇到的容易发生bug的数据点来对别人的代码进行测试，使用python进行核对。 重构经历总结第一次到第二次作业过程中经历了重构，原因是第一次作业没有留下足够的拓展空间，解析字符串过于暴力，但是在第二次作业理解了如何递归下降进行读取解析之后，重构反而显得思路更加清晰，在这个架构下，第三次作业完成的比较容易。由于重构前后属2次作业内容，没有可比较性，故未通过数据进行对比。 吸取的教训是：尽可能给程序留下充足的可扩展空间，已经写好的类尽量保证其完备性，在拓展时就尽量不去修改了，类之间的保证解耦，方法复杂度尽可能底，如此下来可以保证程序的鲁棒性。 心得体会第一次作业思维还是比较偏面向过程的，对字符串进行了暴力解析，对象也仅仅停留在所谓的Term和Expression上。 在第二次作业难度骤然增加后，明白了面向对象的重要性，一个接口下的多个类逻辑分明，调用各自的方法，另外，在第二次作业过程中，理解了递归下降的思路，这是一种逻辑非常清晰的做法，为我的第三次作业节省了大量的时间。 第三次作业在格式判断上填了第二次作业留下的坑，更进一步理清了整个程序的逻辑，虽然最后在性能分上没有占到很多优势，但是总体下来我认为代码的结构和逻辑还是很清晰的，代码总计行数705完成了。 总的来说，本次作业虽然遇到一些困难（指第二次作业递归下降和如何优化）但总体来说还是学到了很多东西，包括但不仅限于面向对象的思维，正则表达式的使用，Java容器操作的熟练，递归等。","link":"/posts/56284/"},{"title":"BUAAOO-第三单元总结","text":"BUAAOO-第三单元总结实现规格所采取的设计策略在第一次作业中，开始没有经验，采取了直接对规格进行“翻译”的策略，对数据保存直接使用了定长数组，后发现这样操作代码可读性不高且性能较差，于使重新改写为使用HashMap保存。 第二次作业中，虽然使用容器实现了数据存储，但是算法方面由于直接按照规格描述进行实现，导致了大量的CTLE。于使此后，阅读完规格后我能对方法有彻底理解后再根据自己的理解去实现。 再有以上经验后，认为实现规格应采取如下步骤： 完整阅读规格 选择正确的数据结构，容器 正确处理异常 选择合适的算法实现方法 基于JML规格来设计测试的方法和策略 再次阅读JML规格，检查在方法被实现前，异常是否被正确，处理检查方法是否满足规格的ensure 使用Junit，针对每一个具一定不确定因素的方法编写测试样例进行测试 对程序整体进行大数据集测试 本单元看似简单，但在测试方面我做的并不理想，在三次作业中均出现了非常低级的BUG 第一次： 原因是在阅读JML时并未彻底理解其含义，直接按照规格进行书写，导致进行了逻辑完全错误的一个判断 第二次： 低估了自己犯低级错误的的概率（当然本次作业主要问题在CTLE上） 第三次： 自作聪明在判断异常之前就删除了message，造成了大量WA 三次作业出现的bug基本都是在阅读JML规格时丧失理性造成的，事实证明在阅读JML时候一定要保证独立思考的能力，当然锅也不能全部甩到这里，归根结底还是自己懒得测试且高估了自己写简单代码不出错的能力。 (Junit暴力测试？) 12345678910111213141516171819202122232425262728293031@org.junit.jupiter.api.Testvoid sendIndirectMessage() throws EqualPersonIdException, PersonIdNotFoundException, EqualRelationException, MessageIdNotFoundException, EmojiIdNotFoundException, EqualMessageIdException, RelationNotFoundException, EqualEmojiIdException { Network network = new MyNetwork(); network.addPerson(new MyPerson(1, &quot;A&quot;, 10)); network.addPerson(new MyPerson(3, &quot;N&quot;, 10)); network.addPerson(new MyPerson(6, &quot;F&quot;, 10)); network.addRelation(1, 3, 10); network.addRelation(3, 6, 15); network.addRelation(1, 6, 26); network.storeEmojiId(1); network.storeEmojiId(3); network.storeEmojiId(5); network.storeEmojiId(7); network.storeEmojiId(9); network.storeEmojiId(91); network.addMessage(new MyMessage(1, 10, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(2, 1, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(3, 1, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(4, 1, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(5, 3, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(6, 9, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(7, 91, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(8, 91, network.getPerson(1), network.getPerson(6))); for (int i = 0; i &lt; 8; i++) { network.sendMessage(i + 1); } assertEquals(4, network.deleteColdEmoji(1)); assertEquals(true,network.containsEmojiId(91)); network.deleteColdEmoji(3); assertEquals(false,network.containsEmojiId(91));} 容器选择和使用的经验 避免直接使用定长数组。 根据需求进行容器的选择，如果对象是通过ID来进行大部分操作，那么使用HashMap进行存储，如果对象如Person.messages，需要从头取出，从尾放入等操作，则使用ArrayList进行存储。适当的情景下也可使用Hashset来做集合的不重复性。 不确定要用什么的情况下，似乎还是用HashMap比较靠谱 性能问题本次作业会出现的性能问题主要集中在容器的选择，qbs的算法，ageMean，ageVar等的算法。 对于容器的问题，我的避免超时的方法是采取了适合的容器如HashMap 我在第二次作业中大面积出现了性能问题（估计能踩的坑我都踩了） qbs的算法采用了规格描述的算法直接进计算，于使我对其进行了并查集算法的修改，在addPerson和delPerson的时候就对拥有同一个根节点的节点构成一个集合。（一开始还写了DFS，慢的要死就算了，还写了一堆BUG，忙一下午，服了。） 1234567891011121314151617181920212223242526 private final HashMap&lt;Integer, Integer&gt; parent = new HashMap&lt;&gt;(); private final HashMap&lt;Integer, Integer&gt; rank = new HashMap&lt;&gt;();private int find(int id) { if (parent.get(id) != id) { parent.put(id, find(parent.get(id))); } return parent.get(id); } private void union(int id1, int id2) { int p = find(id1); int q = find(id2); if (p == q) { return; } if (rank.get(p) &lt; rank.get(q)) { parent.put(p, q); } else if (rank.get(p) &gt; rank.get(q)) { parent.put(q, p); } else { parent.put(p, q); rank.put(q, rank.get(q) + 1); } } ageMean，ageVar等的计算，起初我的计算直接采用了每次调用方法是从头开始计算的实现，结果导致每次计算要消耗大量的CPU超时，导致了CTLE，后改为在进行addperson的时候直接进行累加加和的操作，在询问ageMean的时候可以直接进行返回。 123456789101112131415161718192021222324252627282930313233343536private int ageSum = 0;private int ageMean = 0;private int ageVar = 0;private int valueSum = 0;@Overridepublic void addPerson(Person person) { people.put(person.getId(), person); ageSum += person.getAge(); ageMean = ageSum / people.size(); ageVar = 0; for (Person p : people.values()) { ageVar += (p.getAge() - ageMean) * (p.getAge() - ageMean); if (p.isLinked(person)) { valueSum += p.queryValue(person) * 2; } } ageVar = ageVar / people.size();}@Overridepublic void delPerson(Person person) { people.remove(person.getId()); if (people.isEmpty()) { initialData(); return; } ageSum -= person.getAge(); ageMean = ageSum / people.size(); ageVar = 0; for (Person p : people.values()) { ageVar += (p.getAge() - ageMean) * (p.getAge() - ageMean); if (p.isLinked(person)) { valueSum -= p.queryValue(person) * 2; } } ageVar = ageVar / people.size();} 架构设计除了各个对象的HashMap以外，network维护一个并查集，group维护多个基本数据，在addPerson的能操作时进行各个数据的更新。 不知道写什么了，这单元挺搞心态的，对自己写BUG的能力又有了新的认识，因为自己时间不够能力不足，总做不好测试这一块，我也不知道怎么办，就尽力别写bug吧。不讲丧气话，这单元学到了JML规格相关知识，好像还是挺“严谨”的，如果以后工作或者什么遇到了，应该挺受益的，不过有一说一，我是不会愿意去自己写这个JML的，如果有中文版的JML能几句话讲清楚，那没准可以试试。","link":"/posts/4801/"},{"title":"BUAAOO-第四单元总结","text":"BUAAOO-第四单元总结总结本单元作业的架构设计本单元任务为设计UML分析器，包括类图，顺序图，状态图 第一次作业实现类图分析 将UML元素根据其含义分为如下层次结构 部分元素根据需求分装为MyXXX 根据逻辑层次，读入过程分为三个循环，分别处理三个层次的元素 循环轮次 处理元素 1 UmlClass UmlInterface UmlAssociationEnd 2 UmlOperation UmlAttribute UmlAssociation UmlGeneralization UmlInterfaceRealization 3 UmlParameter 第二次作业实现顺序图，状态图 将UML元素根据其含义分为如下层次结构 部分元素根据需求分装为MyXXX 根据逻辑层次，读入过程分为四个循环，分别处理四个层次的元素 循环轮次 处理元素 1 UmlClass UmlInterface UmlAssociationEnd UmlInteraction UmlStateMachine UmlRegion 2 UmlOperation UmlAttribute UmlAssociation UmlGeneralization UmlInterfaceRealization UmlLifeline UmlState UmlPseudostate UmlFinalState 3 UmlParameter UmlMessage UmlTransition 4 UmlEvent 第三次作业架构同第二次。 其他的就是一些图算法的问题了。 总结自己在四个单元中架构设计及OO方法理解的演进 单元 理解 第一单元 面向对象的层次化设计：factor，term，poly层次结构逻辑分明，各司其职，同时又都实现某接口，递归下降的操作过程中非常符合人的直觉感受。认识到清晰的逻辑架构的重要性。 第二单元 多线程设计：多线程的加入使得程序有了更多的不确定性。线程之间的交互在逻辑需要深入理解，UML流程图的作用。 第三单元 基于JML的设计：学到了JML规格相关知识，工程化思想进一步提升 第四单元 UML：清晰且彻底的理解了面向对象层次化设计的形态和结构 总结自己在四个单元中测试理解与实践的演进 单元 理解 实践 第一单元 利用python生存复杂数据，边界数据进行测试 第二单元 需要考虑线程之间时间差异可能带来的问题，性能方面也要注意特殊情况，形式化验证 第三单元 没怎么测，错了一片，看来测试很重要 第四单元 利用工具，手动构造较为复杂的UML图，进行测试。 总结自己的课程收获​ 16周连续的任务（其中一周有休息）任务量确实比较大，回首自己的前三篇博客，也能看到自己泡一天图书馆写程序的影子，为BUG抓狂的夜晚，周三看结果看到“你在强测中得到0分”的悲痛心情。 ​ 每周精确到天的任务，不得不说，这是一门硬课。但重要的是确实看到了自己的在这门课上的收获有多大。这是一门实实在在能学到很多东西的课程，无论是代码风格，程序基础，性能算法，还是最重要的架构设计，我都得到了比较大的提升，在最重要的架构设计上，我深刻理解了对于复杂程序甚至是工程程序中，无论是对个人还是团队合作，面向对象思想的重要性。 ​ 前几周投入的精力更大一些，第一单元和第二单元收获颇丰，得分也比较好看，第三单元有所松懈，有幸得到了强测0分体验。这门课没有考试，却比考试周突击的课能学到更多东西。 ​ 虽然最后作为社恐和菜鸡没有在研讨课发过言，也没得到什么奖，或许最后得分比较一般，但是这门课确实是我在计算机学院到目前为止感觉上的最舒服的一门课，没有什么遗憾了。 ​ 非常感谢可爱的吴际老师一学期的辛勤教学，lyj学长前两单元架构经验的倾情分享和研讨课课程组织，还有其他助教们全程的辛勤付出！ 立足于自己的体会给课程提三个具体改进建议 建议第三单元第四单元互换时间，第三单元内容简单，适合考期时间紧张的情况下写，第四单元的工作量相对来说太大了，难顶 对于面向对象这门课，希望少一些算法考察，第三单元的CTLE现象太坑人，第四单元的图算法太多，虽然算法也是必须掌握的内容，但是在本来任务量就大的情况下，我认为重心应该只放在架构设计上 第三单元可以压缩，三次作业难度都明显低于其他单元。 第四单元的重复工作希望可以有所减少，代码量感觉有点大。 希望每个单元的三次作业的描述能标记增量部分，每次拿到大几千字的文档，好多内容都和之前一模一样，也容易看不进去 研讨课加分政策感觉有点卷了，对于我这种又比较弱又社恐的人有种被push的感觉 （超过3个了，不好意思） 以上仅是作为一个比较弱的人的个人主观想法，可能存在发牢骚现象，如有不合理内容请无视，相信课程组多年来积累的经验，祝OO课程组越来越好！ 完结撒花！！！","link":"/posts/8987/"},{"title":"Memo","text":"MemoMemo用于随时记录，记录生活中的某一刻，记录今天的心情，或是记录看过的一部电影，一本书，留下自己此时的感想，并在自己最爱的电影或书籍的二刷三刷后再次记录下时间和新的想法… 灵感来源于豆瓣，比起豆瓣的功能多出的个人需求为：需要一个简洁没有过量冗余信息的片单和书单记录软件，记录二刷，三刷的时间，以及想要随时记录每一天，并且在几年后回顾那年今日，留一些感动与感慨，让每一天都值得被纪念，故开发此软件。 图片 （介绍及短评摘自豆瓣，侵删） Mac, iPad适配 简介主页面主界面分为3个标签：主页，电影，书籍 主页 电影这里是你看过的电影片单，你可以随时看到你标记过的所有电影，以及在任何时候添加一个新的电影进入你的片单 进入某条电影，如果你输入的电影在数据库之中（数据来自豆瓣，侵删），你就可以看到关于电影的介绍：演员，导演，豆瓣评分，类别，介绍等，以及最重要的，在最下方，看到你第一次观看的时间以及感想 当然，点击此方框，你可以进入到第二次标记的页面，记录下你的第二次观影以及新的感想 书籍类似电影，这里是你的书单，你可以添加你看过的书籍，并且记录第n次阅读的体验，相信每一次阅读，都会发现不少新东西 功能 标记某一天的感受 标记某本电影，某本书 多次标记某电影和书的观看时间和感受 自动展示电影和书籍的相关图片与简介 图文并茂的主页卡片展示设计 在主页展示进一个月看过的电影 在主页展示今天以及那年今日的感想 架构以及实现源代码文件共25个 主要分为三个部分：Controller Model Views Controller一些静态函数，实现点击界面按钮后的某些后端反应以及后端用到的函数，如图像获取，日期格式化，Mark筛选等 其中图片的读取使用了异步加载url的方式，如果url没有解析成功将不会显示图片 123456789101112131415161718192021222324class ImageLoader: ObservableObject { var didChange = PassthroughSubject&lt;Data, Never&gt;() var data = Data() { didSet { didChange.send(data) } } init(urlString: String) { guard let url = URL(string: urlString) else { return } let task = URLSession.shared.dataTask(with: url) { (data, response, error) in guard let data = data else { return } DispatchQueue.main.async { self.data = data } } task.resume() }} Model主要用到的对象为Mark： 123456789101112131415class Mark: Codable, Identifiable{ var index:Int = 0 var type:ModelType = ModelType.NONE var name = &quot;&quot; var dates: [Date] = [] var feeling = &quot;&quot; init(index: Int,type:ModelType, name:String, date:Date, feeling:String){ self.index = index self.type = type self.name = name self.dates.append(date) self.feeling = feeling }} Movie, Book 为电影和书籍的简介，不进行重复的展示 他们遵循MarkableObject协议，用于在展示Mark详情时读取object后再作类型判断 1234struct Movie: Hashable, Codable, Identifiable, MarkableObject { var id: String = &quot;&quot; ...} ModelData负责数据存储的任务 用到了自带的UserDefaults.standard存储数据 movies和books分别为电影和书籍数据集，内置在app中 123456789101112131415161718final class ModelData: ObservableObject { var moviesDict = getMoviesDict(movies: load(&quot;movies.json&quot;)) var booksDict = getBooksDict(books: load(&quot;books.json&quot;)) @Published var marks: [Mark] = [] init() { loadMarks() } func loadMarks() { marks = UserDefaults.standard.object(([Mark]).self, with: &quot;Marks&quot;) ?? [] } func saveMarks() { let standard = UserDefaults.standard standard.set(object: marks, forKey: &quot;Marks&quot;) }} ModelType为枚举类型，用于Mark类型判断 123456enum ModelType: String, Codable { case NONE = &quot;无&quot; case MOVIE = &quot;电影&quot; case BOOK = &quot;书籍&quot; case DAY = &quot;今天&quot;} Views界面UI 用到了environmentObject来同步各个界面的数据 父界面给子界面传递@Binding的变量，子界面拿到引用直接演示和修改，不会出现数据不同步的问题 12345678910@mainstruct MemoApp: App { @StateObject private var modelData = ModelData() var body: some Scene { WindowGroup { ContentView() .environmentObject(modelData) } }} MainMenuMarkList: Mark列表，即展示电影和书籍列表 使用NavigationLink，向子界面：MarkDetail传递mark的引用 HomeView: 主界面 Mark关于Mark的界面 MarkDetail: 一个Mark的详情 大部分子界面都如此UI一样，引入modelData的环境变量，承接上一级传下来的@Binding变量，实现数据的同步 12@EnvironmentObject var modelData: ModelData@Binding var mark: Mark 其中要进行object的解析，如果用户输入能索引本地数据集的一个条目上，将会展示此object的详情 MarkAdd: Mark增加界面 MarkEdit: Mark修改界面 MarkToday: 标记今天界面 这三个UI都用到了@State来实时同步Form表单中的信息 以至于用户输入能够及时的反应在变量上并且写入modelData Kit其他组件 电影和书籍详情，时间线，圆形和方形图片，卡片组件等 均已展示在各个页面中","link":"/posts/53100/"},{"title":"BUAAOO-第二单元总结","text":"BUAAOO-第二单元总结作业分析同步块与锁InputThread捕捉输入，将其加入waitQueue队列中 Dispatcher负责控制waitQueue，对waitQueue的操作需要经过Dispatcher Elevator为电梯个体对象，其内包含一个requests用于表示目前位于电梯里的请求 其中，锁全部位于调度器中 例如 12345678910111213public PersonRequest checkTopRequest() { synchronized (waitQueue) { int max = 0; PersonRequest request = null; for (PersonRequest r : waitQueue) { if (r.getFromFloor() &gt; max) { max = r.getFromFloor(); request = r; } } return request; }} 三次作业都为相同的设计，Dispatcher基本没有变动。 调度器设计与线程交互外部可以放心与调度器进行交互，类似生产者消费者模型，调度器维护waitQueue，输入线程通过调度器向其中加入请求，电梯通过调度器查询和获取请求 第二、三次作业中加入了多个电梯与dispatcher交互 电梯策略： Random：自由竞争，直接去找队列中第一个目标，接到请求后，优先处理电梯中的第一个请求，在运行过程中在每层判断是否可以接送乘客并且进行操作。 Morning：电梯位于1层，开始接人，2s后出发，一直送到电梯内请求列表的最高层后返回，依次循环 Night：直接前往队列中最高层接人，向下过程中继续接人，回到一层后依次循环。 UML第一次作业Main创建输入和电梯线程以及调度器，输入线程提供mode，requests，end等，调度器负责控制队列，elevator进行运行。 流程图： 第二次作业相比第一次作业，输入线程负责创建新的Elevator 流程图 第三次作业结构和第二次没有什么不同，在电梯类内部进行了ABC的区分，没有进行换乘的优化，仅仅是规定了各个电梯可人的层数后进行自由竞争。 流程图 分析自己程序的bug在第一次作业没有互测bug。 第二次作业自测的bug主要集中在没有正确结束线程。互测没有被找到bug，但是强测出现了一个超载的bug，原因在进行电梯可承载人数时加减号使用错误导致超载。 第三次作业自测阶段的bug主要在电梯由于型号不同，理论上结束标志不一，我在while循环结束的时候仅判断了input的信号，导致部分电梯提前结束，后来又因为没有正确结束导致while死循环CPU超时。 在互测中被hack一次，原因是我没有进行换乘优化，对方的数据点为集中的密集底层到高层数据，我的电梯只有C会去接人，导致超时。 分析自己发现别人程序bug所采用的策略能力有限，这几次没有对他人的程序进行bug测试 心得体会多线程的加入使得程序有了更多的不确定性，增加了测试的难度，但总而言之，只要做好线程的安全，如定义好线程安全类在进行操作，处理好线程的结束，不产生轮询，就可以避免多线程带来的bug。线程之间的交互在逻辑上就如同P6流水线的竞争一样，需要进行大量情况的考虑。在这几次作业中，我学会了多线程程序的正确处理。 最终代码量","link":"/posts/54734/"},{"title":"Hexo-Front-matter","text":"Demotitle:date: 2021-11-23 10:09:18tags: [hexo]categories:cover: 官方说明以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 excerpt Page excerpt in plain text. Use this plugin to format the text disableNunjucks Disable rendering of Nunjucks tag {{ }}/{% %} and tag plugins when enabled lang Set the language to override auto-detection Inherited from _config.yml thumbnail 封面","link":"/posts/37095/"},{"title":"Django相关","text":"数据库转类 python3 manage.py inspectdb 解决冲突问题 123456class UserEvaluate(models.Model): user_evaluate_id = models.AutoField(primary_key=True) user_evaluate_text = models.CharField(max_length=100, blank=True, null=True) user_evaluate_score = models.IntegerField(blank=True, null=True) user = models.ForeignKey(User, models.DO_NOTHING, blank=True, null=True) post_user = models.ForeignKey(User, models.DO_NOTHING) 后两行改为 12user = models.ForeignKey('User', models.DO_NOTHING, blank=True, null=True, related_name='user_evaluate_1') post_user = models.ForeignKey('User', models.DO_NOTHING, related_name='user_evaluate_2') Django 腾讯云函数部署 如何部署","link":"/posts/undefined/"},{"title":"MacOS全局可执行文件","text":"sudo vim /usr/local/bin/command /usr/local/bin/ 下创建的文件默认在path中必须使用sudo 12#!/bin/bashdo something sudo chmod +x /usr/local/bin/command 即可全局使用 command","link":"/posts/62285/"},{"title":"Hexo食用方法","text":"Blog搭建https://zhuanlan.zhihu.com/p/26625249 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 安装：npm install -g hexo Hexo指令基本1234hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 域名解析在github项目根目录新建一个名为CNAME的文件，里面填写域名 然后CNAME解析 图片https://www.cnblogs.com/bzsheng/p/13802829.html","link":"/posts/27962/"},{"title":"Unknown collation- &#39;utf8mb4_0900_ai_ci&#39;","text":"运行sql脚本时 sql报错如下 Unknown collation: ‘utf8mb4_0900_ai_ci’ 原因mySQL版本不兼容，将sql文件中 utf8mb4_0900_ai_ci 替换成 utf8mb4_general_ci","link":"/posts/12888/"},{"title":"假如爱有天意","text":"《假如爱有天意》 最近又在听《假如爱有天意》，遂又回去二刷原作一年了，依然感动","link":"/posts/19611/"},{"title":"我爱我度过的所有时间","text":"《现在去见你》 哪怕早知道我会早早离开，也不愿辜负有你们的这一生。","link":"/posts/11914/"},{"title":"西方音乐鉴赏第八次课","text":"肖邦波兰 历经坎坷的国家 波兰沦陷时一直在播放《革命练习曲》钢琴诗人 只创作钢琴音乐《E大调练习曲（离别曲）》1830年后在法国巴黎发展《第6号（小狗）圆舞曲》 音乐的诗情画意 采用不对称结构 朗诵音调 自由速度 tempo rubato 遗作 《升C小调夜曲》 具肖邦特色 音乐中的民族性玛祖卡舞曲： 3/4拍舞曲 重音在第二拍 曲式：回旋曲式 ABAC 谐谑曲 四首谐谑曲。 其中《降b小调谐谑曲》 最富于诗意 曲式：自由的奏鸣曲式 3/4 拍 中期浪漫主义 - 歌剧威尔第 《奥菲欧》 意大利 威尔第主要采用浪漫主义时期小说创作 作品： 早期 《纳布科》 合唱《飞吧，金色的翅膀》（被称为意大利第二国歌） 中期 《弄臣》 《游吟诗人》 《茶花女》 晚期 《阿依达》 （巅峰之作） 创作特点： 分曲体结构 强烈的戏剧冲突 咏叹调和宣叙调采用乐队伴奏 旋律简单易记 拓展歌唱家音域，增加紧张和激情 自由速度 有戏剧结构。场景与卡巴列塔常常出现在歌剧的每一幕结尾 乐队不可喧宾夺主 德国 瓦格纳文学家，戏剧家，音乐家，哲学家自创歌剧 神话色彩音乐戏剧 “乐剧”独特的德国歌剧 作品 《汤豪瑟》单三部曲式ABABA 四联剧 《尼伯龙根的指环》 史上篇幅最大作品 序夜：《莱茵的黄金》 第一夜 ：《女武神》 第二夜 ：《齐格飞》 第三夜 ：《诸神的黄昏》 创作特点： 无终止旋律 器乐是统治一切的原则（乐队淹没人声） 主导动机的手法 浪漫主义晚期-勃拉姆斯的创作勃拉姆斯德国作曲家“浪漫的古典主义”作曲家 作品： 《摇篮曲》 室内乐《C小调第三钢琴弦乐四重奏》-献给克拉拉([[第七次课]]) 《第二交响曲》 柴可夫斯基俄国作曲家受影响：俄国民族 能歌善舞俄国社会 沙皇统治时期，农民起义三个女人 初恋(法国歌唱家) ，妻子，精神支柱 作品（涉猎各种题材）： 三部芭蕾 《天鹅湖》 《睡美人》 《胡桃夹子》 七部交响曲 《E小调第五交响曲》-命运动机-贯穿四个乐章 … 理查德 施特劳斯《七纱舞》 马勒奥地利作曲家","link":"/posts/28200/"},{"title":"西方音乐鉴赏第七次课","text":"西方音乐鉴赏课 早期浪漫主义艺术歌曲主要采用诗人诗作 钢琴：伴奏烘托 歌唱：意大利美声 例：《魔王》——歌德叙事诗 舒伯特艺术歌曲（600多首）、交响曲…… 作品比前人更具有抒情性，充满歌唱感 艺术歌曲《鳟鱼》 交响曲 《第八未完成交响曲》 罗伯特 舒曼19世纪德国作曲家、音乐评论家 《蝴蝶》《狂欢节》《童年情景》 钢琴《A小调钢琴协奏曲》OP 54 《桃金娘》（单三部曲式 ABA）献给爱妻克拉拉（著名钢琴家） 标题音乐分类： 音乐会序曲标题交响曲交响诗 音乐会序曲门德尔松（学院派作曲家，风格多奏鸣曲快板，甜美轻盈）首创 门德尔松《仲夏夜之梦》序曲 门德尔松《婚礼进行曲》 瓦格纳《婚礼进行曲》 埃克托 柏辽兹交响曲 《幻想交响曲》 李斯特交响诗《前奏曲》 曲式结构 4/4 自由-奏鸣曲 呈示部——展开部——再现部——尾声 钢琴音乐音域拓宽，音锤改为毛毡布包裹，钢琴装上2个踏板 舒曼《儿时情景》——《梦幻曲》 门德尔松——无词歌《春之歌》 弗朗茨 李斯特钢琴之王，作曲家，宗教神父 三部曲式 钢琴小品《爱之梦》","link":"/posts/29007/"},{"title":"C++基础","text":"结构 123456struct Student{int i;int j;char c;} 由于int需要占用4个字节，由于结构的空间分配是大对齐，总共需要12个空间。 当然也可以压缩空间，把它压缩为实际只使用的9个字节。 压缩： 1#pragma pack(1) 宏函数宏 1#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0]) 控制宏 123456#define HOME //用于控制开关#ifdef HOMEcout &lt;&lt; &quot;link a&quot; &lt;&lt; endl;#elseifcout &lt;&lt; &quot;link b&quot; &lt;&lt; endl;#endif 123#ifdef WIN32 //windows平台上一定会有的宏#include &lt;windows.h&gt;#endif 如果把C++程序和C程序混合编译 1extern &quot;C&quot; void fun_C(); 这个语句就是用于告诉链接器，这个函数是用C标准编译的，不要按照C++编译器修饰的方式去找。 函数 1234567891011//1.overloading//2.default parameter//默认参数必须放后void fun2(int a, int b = 3, int c = 4) { cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;}//3.占位参数void fun3(int) { cout &lt;&lt; 233 &lt;&lt; endl;} C++ 面向对象1234567891011121314151617struct Person {private: int age; char *name;public: Person(int aage, char *aname); ~Person();};Person::Person(int aage, char *aname) { this-&gt;age = aage; this-&gt;name = aname;}Person::~Person(){ //析构函数} struct和class区别：class默认成员变量private 默认构造：不带括号 123456Test t1(3);Test *t2 = new Test();Test t3(2,3);Test t4(); //this is a functionTest t4;Test *t5 = new Test(3); 函数的原则：尽量不用返回值去返回，输入输出参数放在参数里 成员变量原则： value：必然组成部分 address：可有可无的部分 类嵌套： 1234567class Point;class Circle{ Point *p;};class Point{ Circle c;}; 析构函数(destructor)： 对象消亡时自动调用 可用于free堆区malloc 防止重复free，free时： 1234if (p != NULL) { free(p); p = NULL; } 指针与引用指针的问题 1234//1. fly pointer (if null / assert)//2. memory leak (free)//3. return addr of local var//4. multi-pointers for one object 引用 123//reference 引用int m = 5;int &amp;r = m; //m的小名 对象的copy 12345678//bitwise copy 浅拷贝（默认） vs. logical copy 深拷贝//copy constructorTest::Test(Test &amp;t) { this-&gt;i = t.i; //!!!this-&gt; = t.j this-&gt;j = (int *) malloc(sizeof(int)); *j = *t.j;} e 12345// pass by value vs. pass by address(pointer or reference)//效果 read read/write//性能 sizeof(object) sizeof(int)//麻烦 copy-constructor nothing//conclusion: never pass by value(build-in type except) new and delete12345678//Test *p = (Test *)malloc(sizeof (Test));Test *p =new Test(1,2);//new = malloc + constructordelete p;//delete = destructor + free;//多个对象Test *p = new Test[10]; //要求有默认构造delete []p; 常量12345void Test::fun() const{ //read only function};const Test t;t.fun(); static123void fun(){ static int i; //堆区，与全局变量同} extern全局变量不定义在头文件，定义在某一源文件中 extern外链接放在头文件。 函数默认extern外链接，用static修饰表明作用域为本文件。 1extern int g_i; 类中static修饰：全类的共享空间 123456789class test{ static int i; int j; public: Test(int aj);}//显示一次性初始化int Test::i = 100; static无this指针 operator 重载运算符 [] 重载数组 * 重载取内容 new delet 重载malloc ++重载++ 12345678910111213141516171819202122232425262728293031class Account{ int id; int balance;public: Account &amp;operator+(int n); //++a Account&amp; operator++(); //a++ Account operator++(int);};Account &amp;Account::operator+(int n) { this-&gt;balance += n;}Account&amp; Account::operator++() { this-&gt;balance++; return *this; }Account Account::operator++(int) { Account old = *this; this-&gt;balance++; return old;}int main(){ Account a; a = a+100;} 继承(inheritance)与组成(composition)12345678910111213//(derived class)子类class Student : public Borrower{public: void borrow_book(); };void Student::borrow_book(){ Borrower::borrow_book(); cout &lt;&lt; &quot;if&gt;=5 return&quot; &lt;&lt; endl;} 注意构造顺序 子类构造器自动调用父类构造器，析构相反 组成也会先自动调用内部对象的构造(Engine initial - Car initial) 12345678//构造器初始化列表(若没有默认构造无法默认调用)Derived::Derived(int ai, int aj):Base(ai){ }//有先后顺序Test::Test(int ai, int aj) :i(ai),j(aj){ } 多继承(菱形结构) 1class Derived : public Base1, public Base2{} 多态 upcasting 向上转换 later binding vs. early binding polymorphism 多态性 virtual constructor &amp; destructor 构造无多态，析构往往多态 abstract class (interface in Java &amp; C#) 123456789101112131415class Pet{ char *name; int age;public: virtual void speak(); //虚函数 内存占用+8 子类自动virtual};#include&lt;cstdlib&gt;void Needle(Pet&amp; pet) //never pass by value 拷贝构造使多态失效{ //binding //1. early binding //2. later(dynamic/runtime) binding pet.speak();} 多态的实现： 类：V-table 虚函数表 对象：V-ptr 指向本类虚函数 123//纯虚函数virtual void speak() = 0;//抽象类：含纯虚函数，无法创建对象 行为串联：当两个类别家族因为行为共性发生关系时，用抽象类来关联两个类别家族 template class1234567891011121314151617181920212223//template class 模板类 collection in Javatemplate&lt;class T&gt;class Stack { T pool[100]; int top;public: //内联函数 inline function //top=0 Stack() : top(0) { } void push(T v) { pool[top++] = v; } T pop() { return pool[--top]; }};int main() { Stack&lt;int&gt; s1; Stack&lt;double&gt; s2;} STL 123456789101112//STL: standard template library#include &lt;vector&gt;int main() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10000; ++i) { v.push_back(i); } cout &lt;&lt; v[9988] &lt;&lt; endl;} iterator 123456789vector&lt;int&gt; v;for (int i = 0; i &lt; 10; ++i) { v.push_back(i);}vector&lt;int&gt;::iterator it = v.begin();while (it != v.end()) { cout &lt;&lt; *it &lt;&lt; endl; it++;} name space类上一级层次 1using namespace my_nsp try catch 和Java一样 assert 12//让断言全部失效#define NDEBUG friend","link":"/posts/44178/"},{"title":"失败的逻辑课程笔记","text":"93390edcd15e5f6c1bd2bb50946e15a3c228597d8e9b4233807f58a26256747043da993285a932618e08251cb20051e5313c16c84716189ed55a3c482c73dab6d25ee6e6f74e8b51abdaaaf8bd377a8ba969434c8fb94d697f9b0707fc1bafeabac527d68d711871289a46f022877155cab52f535845daa533b2ab714734dbc95c91f7b29672e119ff6728a2d9b21fae1a0640cbd011496d5f5db17debd36a6c4d7ace39571ead8a4846b66ce803579f206d36b8e3d18e55a2208b32c89e1e075fdb75233b3bf7a8e843084d722f6500a511ea9dac9e2d995afd8aa7dda0cd9dc41d49e8e32bad96e26e73591c1f86f4d44af1bc092218f6cb7a58c026a47f51c6c36da7d7c603bebab6f46ad354f963b02521bda0db34ed7f2ed6e51cf9d30cd8fd077f162f53f048bf8068bdd9be4d0b3d78cff94a99563b9e139fa804899e1eeb35eb171c23f73d4827187008802953fef05e6c19ce01a4770eb2eae34512f47e398e0843929b56f4547853fce2f8eb93f32cc62be02fe633d230233a0f50c2e67cc161e6aa6a281f475f047b2d9222cdcb8cb564b1af647fd25bbc1627d9e9402ff2b790fbaaa62272702fb8807daa2071a3bb5747084aadf07a287ce6a4a66e370f43f03a1e3f8f9b8d6da930d493025d9ccd8ef4a84de0f57edc78e42374b6f5fc0288ed5068a7702081de1963bc72067d9b2bea3df4e9645a3b97b9d433eeee2ed3094b1f55bee0eb0d907dd8a6c3bd5744ed2108034de48dfeb588d7de9c006b0db2aedbcce9f8f266f16b688074fc84b26c2949fef5c16df3a312243f11ee183c90b189833d0dd40ae446d8b0682fbe325927ddd1fbe0ff920ac06ba58d79d8c920776975acfd2513d3ad4374559c5287bf2b7c12d5190cc5bc4825c0e9b52c5403d6effb06416806032786fda7b8c210b37040db549ee7b3a43bfdf1bacc05cad5875c915f51e9d696790e7d8018fd0ab12d5ecbc148834d1c78aaf24a8d6f1d7533dde4934dceb29e9c2132c4f157641966cc1df27c6aef75732c5470e4b654bab3e2ebbd2a1913ad0c8a73f4895f5b2f0ea23001e6491f3153da43be53f36d5fd1eb3ea16dc5c26b29ee795347d976a7e274e02075b73e3d95432adaed5b5668b1fed591f6ef03a41a118eb156a42fa113f53d0ad8294a6fa8b158eb30e755f1d9a371b6dad332aba65f8db88b3f28c24c1aa19e55bbd5fd7d33290dc61984936814fcf19f36ddf612fd5c6454c0fc2d1e4067be9cda7268e3e2520dd75227036cb96ece9c79baf3582c19052d0a8762d51a5fa27c7231faba57cd1a9c9178d3836163fb2105f545ca22275034b0d06c8ade5436a27f09af56a714e0f3e97289526ca152c5b35019d2ad53ca510e4713142a25a93183ed1a93a017e7c227aa0cc9d88783c7ec0a55f0c88f10454e782f01d2b3b20779c689a74f12f5bf3ea2a899347873a80b35993c379ea36a9ef5762655a607b14fd6f57e28388ddb3ff8b7d8d50720487dd0e0bcf005d812936578b42e4bf4e9de3613940e1215554b0200a71153564ec985493ac03ccac7fe7a4878ecb1f9bf08158a98f56ffa9209272db752260f73472513b7725c9aeb05b7b5cc94afcc07c10b18a5a33055fba890925275d5cd766242a28769250bec39d98a4a9bcf0fc3fc7cfc5190511c7d660ee0a74468d2693de3df275f945e67a85e999788882172f5153e04aabb648fc6b7f5a8b7166b91f040e804f839159fb8bbe5b81af2bffbfa7c5eecbc7e4f2d2c2511c6e97449b74012b8858a1bebb1951afe511d34bc31e6af78609a59cf33c9406a5a851c27e7bcde7d188b99878c9b9b2146d1d84754cca37d7c5176dd8c90312580ff3b04f27dcca9478404136e35313a077a1969a867cc2762aee0d9fe32ad0349326a370a27215c91959b89f18a5be29cf28f46faad2176516a7b28155ecd67faac95ceb58b0c1b7830e46794dd7135753b4619ae276e43c42b52930a61b204367e82bd6d2e4c1bfe206745fc4b569c9e0adbf414b829183c805ae4503c7a3f980aceb4e89a634a23d0b05e1453a93567aeb70fb7dccece6995f8f06686eec57c927f138ffc62d495472c5ca48f6eee4c6bd075d3f10406c09988eeb9482c0c66600be47a887aae2eed823a2be00d0cbb682262ad908d03ba8948c6a166ab5a34518c62afea7d6ffd294c087b41aacd1694627f93ce6bbda6766ae1d20e5da73475818feff633d96387accf2ad53a5b9449e12d73af5d08e0c25bc656c0a3eb23e024795f9c115634811c6bb00c64a702c1711fcc816fe041d71e12e9f29bbd6f6f2027eaa66faf9918aad17543e27d8c29803961da4f5c103b5aee6c4b43862340262c365ab85b51d870eb34feb0102baeefc1ac6c7526b8aeca3ee6c9ae151bb7245caa36bb23c735e16054c520c8bb98d0b30da680e38791072c5e2aa8a6df1dff3caebce6f31cd25d5fad70b3b0e7924ff576b8346502bb1177ba75950490b520a91fb338291c0ef8fde819ea4c7352c7150e5049fb45708e429eeca6d27387c9fb2422ee4b9c33aa3445853d6140e2b3073172dfda401710f1c3d93bfdaa01008926e032d52af00bacf0a78334daaa2383273a6f64c23a684b0a04be4e38429c9e1166aa2a768e44af6af8420514203c2315cfdd7c89362b2588f3fac98b82e91e2f0dbdc55b4412a02ec11d9d4824d89ff61f939c2debf02db8738041fea1ef56d0395ebcd2a5b17a2b4e78652022c8ad3b47f983d2e8059345e6a0c29280ae14a247ce6137f08121f9c5128e2ab0e0727f4b1a34ff9b66f2a090caefa16d16a19f8c0c520f554c3057a38aec63a8b651c850033bad8627ac42096bc5a1ede0b22bd4601c17596e2ca52d6d875c08244166879f2312f767732ee6cd77f3e9a70f2ef4f60a7da54cab67641634c3ce6f86c90d352171e02a24faeddeb644fbbf0c67c765be2a7ce84f809e459965445cd9124e6ce9cd9821c8713d2603a92613b81418300c836a561f7428ae3cc68ec331c976a5d8fdf760c75a30a1c18064614d7e982ad82a8ad827199c81616a64c751510fa779679134e66da7d16405b91ec285522c1ee6fb317587906c8d8f54308305dcc96133de9b03e67a09cf24001f666fad2f52bab3bd7ffcdd47234b5bb352441b18db84b056e33a940f2bfb0cabf535fffae1043848689a6f95842f8ccbfed65213bc1bcf4a1c081eb8c1f924044b3aa84fb39a36b1c9e1bff101b5b8b55758865bf71ae2d6e55a092dd94a63f9ee6c37ae6fff69d8d4610c54dc9e762f7da746669be9df4debea2f6113dbca610deb57d8e91deb829895bddecc059e5ae94812c45814021a71de51486904de05b9b85c430c6bf15afc6e4217446cd45e880299649d9d0460887d3d74ee9021da19f79d6092eeaece1218c6f32bbe5593869fd69111a6136aa95fd2b02c095f8ce1f8de81cf0bd4ba9fcf03eba27e13ed1fd5726e47b500f35cbfc66f9c1510aa2e24646a0dcbef112de16b7f178bf7612d24f3932709c9c3a61f96856c811f408927ff7e77921a02b451eba30666a944b62bc51412e0195a9930bb9e31f10e41b19b47ffdd0e427c443f5eeeafa1fb4c905e3c328634a4d806b5d213b986a2ca2626a83434bbe1e91f46d0838dc359e4cefabbfabbfa5371b977dffbe8cf6dc792895645bf5db469708f04210b05c5bc027cf89c2e1090884040282710fccebede28cc3504b4e0ee416416ff236648b82d72f15e3d7481f32cd0d7acda88888973d642874524537609e04cb8380fed770f3935067ac1b3a3b6ef3a10b8ed209e480449cce5e9298bef4e9d97eabede6f0647f904c3cfec74ef2dbc2f28e41f8bd8839470f0567e67d36d7045a4693baff62196d54ea738584b7aba0c399121467c8d38dc11be258c8dcb1a6e6b620588a5fa05dc639030112faaf3b24c683f8a4316073b7612028297401e63f207a35636ae5a66893472ca1110697d2521d7350065c5b176cd9ef7acd8043acd8855ba9e90976b250227f96c98e0ef3f049d2deaab82eb21b8bd602fff63a1df8835a26f240c675a135775cce0cc7fa19a783de0484829146bd2d6ec8410f873133790468fcc49dde5aa646b76c654ff02108148a4275329c742fd0b3f581a164e19d81720eeb2b5a1a28a695ed9dfe5e7b3adcb81c7a80730c216c306173977f54296af8b692009dc37e453da3f19f4beff8551677848143e19c1edd365abf645bff89315dc71ad2d600be0aaa859f71700caecf555754639869008385037e74dbd08873d7a30dc7e01044f4936551645bc98fe20c729371c5de12a10c94637740c06222f6a622f945f0d763fdeaadb9eff0002b086d62218fc278c6e23569d4aa91520c874c210b8cb6af83a495d630924fbd2cf0803efff8605a8ec8b3ec263a3290542b25e7fb0c2ba9c5705fe6d9d10b272e57fc5db15b9a20a9ca4da6090b15c5b7120ce91a4b1392b5d0838f132fe6258515529d28366fa7c0eeb1e42dcd3a188c73dba16db7e4fc7bfc102bcbb1a28493b1e5cd5eefd6f45d268e613185c7e5f272bd304cc65439badef6108a71350203c61314389aa610ffcef35437fdca243f12ba5ed19fb1ad87457f25364bd437ea850c9b76be1dbeec12b838305bd50cee597c35e87eb600e20b5c6ddf2122bf98c8584c9e05309a73e3c7bb216a23475a77d891c9086c1d83a4bbc2cf327c6a685ca105e198ec52529e3c613f9a81436187dd48c90d19386fbb395e94e1eeefdbd927ecf2ce7a7e28737f7cb513d09870ec166f9d30d672f38d59e0b133f96a5be5fe375e2ac63f129c7ce1422b939a5a0b6ff031fc1ee1d90314d6170aca08cfe1a73afc9e38ec0bdace0d9243a66744f3fdcc9f2fbce3454742eab30a2c91c3ec587da508877c854c7af412c6430211feb5493d247c273f8e3434645cf002ee2302455ebd9827ee684d0646a575fb8ecdf8c70b485b9844dddc9e58a6face2f56bce81065cae376b04def2e27c8cda4b83b53f620a9b7de26b7b7fffa66fe5c4913180e727735c9fd2f6833bea92f96be26edb9610cd3f07206ecdcf5ae90d58a72d64249285dd60a56945da0bcd6556d5c6b25ceda89398c4abad221af176b5814183d4ec8d9dbf62fd2555058db75a464eeeda130e839e54a755527d45d33ad2293f9d0439ad5936f69bce186e1e6da8e2afa0055bcc0305e4dc5be5f67ca6d8a08a71370c6410353ca053a65003b8bf44b1e39d27ce6930f7a3d345369b3ec5eb37fc42011a9d230547ab58e78aa01f975bd61bd85d006c134e22c9a44ca08320b436d29d1c954d637eb2d4a9de20613f2b092219228c2f9f7ae1f9db5f4013c39e3554bc98e4423016b9820fa5329ed5e186e5f0bec4d8ca9fa1fc221fafeeaed9e4c4fee782eda1c6011dbb6e061ebd6f5a9ff2ca960100b3f93199c635a67370a2af08c5fbbf25e6a805042079b9c0b71d22679b75911bd2e600dd88acd39e3d34fd613f11a83b030c12728a5c89f9e19ea23834f07395b50a8a471ef708d5c7788865ff1a355ea970935f78e8a3bb8d9cf88864d2f8b0d4bca49d9cbf36f7730a250c7fbf1a78f4073f643812873a3c736ac51727b6c46d8e81aab3749f469cd3362d2de02afbcba11644c012579ca3a18de15eed97eb4c76a54956a95411c5fa2750b3923f12e4e290c21ce280d30bd0793edd650c6053bb4905bc18cc6a31e9d94946a590275f0053313d00e7eec7b1dae5548ddcfa0352fca953e98168b48c54df5ea6f04ba70b785d47c9bcaa6bbd7935d4919a8e75e900cbc19159ff1ef74adfebab1bcec06606036374372b66e89cb824e030064c76259f4e62168952f52ab8726c81a5aaab8c3d895f73ed4192e055ef17e03aa49efaa9ab802027ce5b8e9ecd619609f1ac491c2feecf6d1b2cf17ebdb71be95c40100d49d04ece5d27b1a2b5e715a0869bf827ed5a6d6ea0948cb30ab15e888ad4e0c61358ecfed57933f7b61cfe7dc667e5160f85160edd6fdba074cec8edd3b0bfb60a5ca10a8df03d7223a2abcce7a1d9d432b2bf9c2962efc7965bb1ef97c947dad3f7b1424cb9b376346f7db3bcfbd835392f67de55f41c2bd8a6681a9627f48958bb6115c49831aff12c1319c8e860143249c8e421eb11b7361d925fce6d5d68558f8f9783d9ef91866da2dd099e5a60b8d5545f8418f409f5b9d253e7e7f0b79750a10c99c01fb3e78cae25c68f0ab68450725be65bdc00217786847bd34deed346f7327c1606a2ac928f36e6304b684151ffd7846c75b35fca88cf2ecfd1b2c28b669a31acf8c35d98cad901b1b238cc4a81cdcc12c3f69f7a432037947f712896fe83ab405bd69bd64c4be848f5eb941c0e9efa3cf4a8419d6a2815d988d41388fbb8f2a037901d442c83915dc861e4e4cc772f9b8b6af01c70f7b357275b2727968eaeed2a3180725eefdae4eff9dd397a86057b5f4e96bf23ae10cab5c4325ddc9b9cb35adc2087130b9258eb72f67a2acffea9aabde74e5b1acb4b9575fd11c659b67e70f8832a2c6d348ee6d996cc1284502e543b71246a4ed3b858810a3eecf051aceffece09cded48356fb69584e470af338c876e8dddcacbe5430d1629b8bf678885cc8c1fa737a5f53c2f8c04f3ba443bf207d83bff525cfbbcdf1973c8d5b6001411b9ef0f17217f244f3e33bfb495c4794b6e49b6cc55d83bde1d31ce729b8712cd6197faa40c16463e18a96c5dc9cc1d824102c56fbbe110b82297ade267443525186ea349f87ba0e955bd07ee07347a1ee5a17805a235b7e2b74ca35a5da7404427fe5f13ff52db3f5ee4ad6388ac0338d25dd5b5f44deb46b45f2b26b530000365d2d327243fe178bd26d7555c84ef2c0811a80079d0def915778496e74b536b1fcb6efec2da1f122d4c4e9a69d8414c8e1d161aa395b748bc3d09e689733faa5528fe4ed3e6591092f07e88a7408861c99f5c9eea80383c4f319805685858445c55ac4d078e49d4516bbc9b9a5e778c8eb846b028f6a5e235a7d3dca5cb7f384f9e0ae59210d5ed1e7fd34d30b9af656ce3e9bb59e42be938f28d178b3d9befc33ea482a667eab1b0a8146f8602220368ee9b736c779e40011349273386c0792e63298f69992fc00240dc6e9179e3 Hey, password is required here.","link":"/posts/10501/"},{"title":"数据库建立","text":"设置自动当前时间时间戳 为timestamp设置DEFAULT CURRENT_TIMESTAMP","link":"/posts/undefined/"},{"title":"Our Little Sister","text":"《海街日记》","link":"/posts/47940/"},{"title":"2021年11月的第一场雪","text":"真的很冷 今天大家的关注点都在S赛，我也未能免俗参与其中","link":"/posts/11219/"},{"title":"关于封校的行为艺术——很有冲击力","text":"今日看到北京电影学院的行为艺术，甚感封校许久政策就是最明显的校内不同群体的利益冲突，比如在BUAA，冲封校冲得最厉害的，似乎是大四的同学，因为很多人急于出去实习科研。对于一些每天的生活只有卷的同学，封校政策并无大碍。对于北航家属呢，此政策影响不到他们的正常出行。对于我呢，在我想出去玩的时候，对政策感到厌恶，在我不想出玩的时候，却也觉得无所谓。 《肖申克的救赎》 更新于2021-11-23 10:17 昨天刚吐槽完这个，今天BUAA就改报备制了，近期也并无心出门 《不至于》","link":"/posts/29594/"},{"title":"何以变革","text":"大部分人做着自己不想做的事情，只是为了生存，这点有史以来未曾改变。有人只是爱好，有人只是在追求功利，摆出一副难看的样子，卑微的为了让自己能或许多有一点点微乎其微的可能性，去屈服，痛苦，下跪，丧失着自由。何以变革，或许少部分值得敬佩的，才是异类。 我选择方式越来越趋向于同一个准则，或许是积累了那么多经验，觉得只要这样做才是应该的，才能让自己快乐，当然，这样的选择方式，在遵循的同时，也不失会带来一些焦虑，然后我又去抑制这种焦虑？就不知道是自己在习惯的过程中，还是做错了。","link":"/posts/27481/"},{"title":"岁末将至","text":"2021年匆匆的过去了，看上面这张图的话，似乎眼前的这些周期都很快将要画上句号。 2021年仍然是不平凡的一年，仍然记得年初开学前的焦虑，现在回首，已是云淡风轻。 昨天也做了一件有意义的事情，终结了我的某个让我焦虑了一年的项目，很遗憾，和一般情况不同，不是顺利完成了，而是我终于宣告退出了，不知是我诉苦奏效还是项目确实没有什么意义，身边人在最后关头支持我的退出。且不谈这个项目的实际意义，我已经丧失了对项目的兴趣，尽管起初驱动我的也不是兴趣，最主要的还是这一年在这一件事上，循环往复的都是焦虑和难以推进，在近期，也是我今年最忙的时间段，项目突然开始快速推进，我借着这个机会，跟老板提出退出。最终什么都没有拿到，倒是这一年，更像是两年，本就社恐，又无经验，还得不到具体的指导，老板问我有没有给我压力，确实也没有，是自己给自己增加了不少压力，而我，2021年末的我，已经不愿再做自己不喜欢的事情了。让此事告终，心情也好了不少。 这几天甚是忙碌，周围人都出去玩乐了，我还在做作业，复习重修的课程。小伙伴今天下午约我出去玩，我才意识到这已经是这学期不知道第几次因为要考试而拒绝了。倒也不觉得情绪低，因为清楚自己在做什么，为什么忙，除了时间确实不够用，熬了几次夜，反倒挺有兴致的。也非常期待下一周，校历第13周的结束，这意味着编译和数据库的结课，数分期中考试的结束，物联网，安卓大作业的结束，虽然此时此刻他们都还没有结束，也不知道会以什么样的方式结束。 写完这篇，Typora提醒我15天后他要开始收费了。回想疫情居家的那一学期，在6系学长为我们讲解数据结构时，看到了学长的Typora，一眼喜欢上了这个软件，专门加了学长好友去问这款软件叫什么，学长告诉我，如果到了6系会经常用到，我还一笑，不曾想过自己会去6系，如今已是在计算机学院的第二年了。恰合主题，时间过得这么快，也算见证了Typora的演变。 岁末将至，敬颂冬绥","link":"/posts/58536/"}],"tags":[{"name":"AtTackCraft","slug":"AtTackCraft","link":"/tags/AtTackCraft/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"BUAA","slug":"BUAA","link":"/tags/BUAA/"},{"name":"编译","slug":"编译","link":"/tags/%E7%BC%96%E8%AF%91/"},{"name":"随想","slug":"随想","link":"/tags/%E9%9A%8F%E6%83%B3/"},{"name":"推歌","slug":"推歌","link":"/tags/%E6%8E%A8%E6%AD%8C/"},{"name":"吐槽","slug":"吐槽","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"古典音乐","slug":"古典音乐","link":"/tags/%E5%8F%A4%E5%85%B8%E9%9F%B3%E4%B9%90/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[]}