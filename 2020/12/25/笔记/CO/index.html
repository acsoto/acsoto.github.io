<h3 id="P6课下"><a href="#P6课下" class="headerlink" title="P6课下"></a>P6课下</h3><p>改数据通路的时候，爆改变量名，有些变量名没改，随手把imm_2改成imm32，de了一个小时。</p>
<p>debug真浪费时间，一定一定要尽可能一次写对，改的时候改彻底。</p>
<p>这个ISE也是真的毫不人性化，我考P5改了一点数据通路，那时候P6已经建工程了，做P6我还以为是改过的，整了半天EX里我都没给传进去PC信号，然后EX里在用PC，不知道在debug什么东西，你线根本没定义，或者线根本端口对不上号，模块缺信号，ISE都不给说，自己要注意的太太太多了。</p>
<p>直接用三目当MUX方便得多（除了有时候搞不清楚signed的逻辑）</p>
<p>P3先入为主了，写了几个MUX，亲身实践又不好改又浪费时间</p>
<p>对比：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>  [<span class="number">31</span>:<span class="number">0</span>] NPC_0 = </span><br><span class="line">            (branch==<span class="number">2&#x27;b11</span>)?ra:			<span class="comment">//jr</span></span><br><span class="line">            (branch==<span class="number">2&#x27;b10</span>)?&#123;PC[<span class="number">31</span>:<span class="number">28</span>],bits26,<span class="number">2&#x27;b00</span>&#125;:<span class="comment">//j 26</span></span><br><span class="line">            (PC+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux_4_32b(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]sel,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]in0,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]in1,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]in2,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]in3,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]out</span><br><span class="line">    );</span><br><span class="line">	<span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: out&lt;=in0;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: out&lt;=in1;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: out&lt;=in2;</span><br><span class="line">        <span class="number">2&#x27;b11</span>: out&lt;=in3;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">mux_4_32b <span class="number">_</span>forward_RS_1(forward_RS_1,regRD1_1,toRegout,ALUOut_3,<span class="number">0</span>,forward_RSout_1); </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>别写没用的小部件…随定随用（连考三周P5后：真不知道自己写P4P5的时候为什么要这样</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> CMP(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] B,</span><br><span class="line">    <span class="keyword">output</span> equal,</span><br><span class="line">    <span class="keyword">output</span> bigger,</span><br><span class="line">    <span class="keyword">output</span> smaller</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> equal=(A==B);</span><br><span class="line">    <span class="keyword">assign</span> bigger=(A&gt;B);</span><br><span class="line">    <span class="keyword">assign</span> smaller=(A&lt;B);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> equal = (regRD1_1==regRD2_1);</span><br></pre></td></tr></table></figure>

<p>P6加指令虽然多，但是分类后就清晰了，分为以下几部分</p>
<hr>
<h5 id="ALU指令：（R型，I型）主要是给ALU加功能"><a href="#ALU指令：（R型，I型）主要是给ALU加功能" class="headerlink" title="ALU指令：（R型，I型）主要是给ALU加功能"></a>ALU指令：（R型，I型）主要是给ALU加功能</h5><hr>
<h5 id="B类：ID模块加，类似beq"><a href="#B类：ID模块加，类似beq" class="headerlink" title="B类：ID模块加，类似beq"></a>B类：ID模块加，类似<code>beq</code></h5><hr>
<h5 id="L-S类："><a href="#L-S类：" class="headerlink" title="L, S类："></a>L, S类：</h5><p>S：可以在DM中创建一个子模块，根据<code>addr[1:0]</code>和指令类型进行分类，用新旧数据按位拼接起来，构成新的WD，不用修改DM，感觉这样更加清晰直观，但多了读DM的步骤似乎会增加延时？</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] dataH=(addr[<span class="number">1</span>]==<span class="number">0</span>)?</span><br><span class="line">            &#123;RD[<span class="number">31</span>:<span class="number">16</span>],WD[<span class="number">15</span>:<span class="number">0</span>]&#125;:</span><br><span class="line">            &#123;WD[<span class="number">15</span>:<span class="number">0</span>],RD[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> WD_new = (sh)?dataH:</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>L：课程组要求在MEM/WB后拓展，不可直接修改DM</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] Hdata=(addr[<span class="number">1</span>]==<span class="number">0</span>)?</span><br><span class="line">						RD[<span class="number">15</span>:<span class="number">0</span>]:</span><br><span class="line">						RD[<span class="number">31</span>:<span class="number">16</span>];						</span><br><span class="line">						</span><br><span class="line">...</span><br><span class="line"><span class="keyword">assign</span> RD_new = (LoadEXTOP==<span class="number">1</span>)?(&#123;&#123;<span class="number">16</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,Hdata&#125;):</span><br><span class="line">				(LoadEXTOP==<span class="number">2</span>)?(&#123;&#123;<span class="number">16</span>&#123;Hdata[<span class="number">15</span>]&#125;&#125;,Hdata&#125;):</span><br><span class="line">				(LoadEXTOP==<span class="number">3</span>)?(&#123;&#123;<span class="number">24</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;,Bdata&#125;):</span><br><span class="line">				(LoadEXTOP==<span class="number">4</span>)?(&#123;&#123;<span class="number">24</span>&#123;Bdata[<span class="number">7</span>]&#125;&#125;,Bdata&#125;):RD;</span><br></pre></td></tr></table></figure>

<p>WB级要用的<code>Adress</code>是传过来的<code>ALUout_4</code></p>
<p>PS:我真是加一个模块bug一次，而且每次觉得可能是很复杂的bug最后发现都是信号忘写了/写错了</p>
<hr>
<h5 id="乘除："><a href="#乘除：" class="headerlink" title="乘除："></a>乘除：</h5><p>一个小型状态机</p>
<p>卡了好长时间的bug：</p>
<ul>
<li><code>mfhi</code>和<code>mflo</code>的<code>regwirte</code>没置1</li>
<li><code>mfhi</code>和<code>mflo</code>的<code>regdst</code>没置01，我以为是写进<code>rt</code>其实是<code>rd</code></li>
<li>忘弄乘除槽的<code>Tuse</code> <code>Tnew</code>了</li>
</ul>
<p><img src="C:\Users\soto\AppData\Roaming\Typora\typora-user-images\image-20201223170512970.png" alt="image-20201223170512970"></p>
<p>（真没想到，因为测试结果是PC多跳了几个值，我以为是阻塞的问题，找了俩小时，最后发现居然就只是信号没搞对）</p>
<p>（而且这ISim会出莫名其妙的bug的，ins没错他解析出来的<code>regWrite</code>是错的，我de了半小时百思不得其解，重开了下Isim就好了，遇到不止一次。）</p>
<p>PS：惊了，我居然在写乘除时候终于发现我的<code>isWritePC</code>一直写成了<code>isWirtePC</code>，有5处</p>
<hr>
<p>以上注意善用<code>wire xx|xx</code>归类，写控制信号的时候会清爽很多</p>
<p>比如这样</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="keyword">wire</span> R_ins = add|addu|sub|subu|slt|sltu|sll|srl|sra|sllv|srlv|srav|and0|or0|xor0|nor0;</span><br><span class="line">	 <span class="keyword">wire</span> I_ins = addi|addiu|andi|ori|xori|lui|slti|sltiu;</span><br><span class="line">	 <span class="keyword">wire</span> save_ins = sw|sh|sb;</span><br><span class="line">	 <span class="keyword">wire</span> load_ins = lw|lh|lhu|lb|lbu;</span><br><span class="line">	 <span class="keyword">wire</span> ls_ins = load_ins|save_ins;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">assign</span> Tnew =   (load_ins)?<span class="number">2</span>:</span><br><span class="line">                    (R_ins|I_ins|jal|jalr)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assign</span> rsTuse = (R_ins|I_ins|ls_ins)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assign</span> rtTuse = (I_ins)?<span class="number">3</span>:</span><br><span class="line">					(save_ins)?<span class="number">2</span>:</span><br><span class="line">                    (R_ins)?<span class="number">1</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

