[{"content":"[a,b]连续证明可积  由一致连续性对$|x'-x''|\u0026lt;\\delta$ 有 $|f(x')-f(x'')|\u0026lt;\\frac\\epsilon{b-a}$ 只要[a,b]上任意分割T满足$||T||\u0026lt;\\delta$ 则f(x)在任一小区间有  $$ \\omega_i=M_i-m_i=\\sup_{x',x''\\in \\Delta_i}|f(x')-f(x'')|\u0026lt;\\frac\\epsilon{b-a} $$ 3. 则有$\\sum_T\\omega_i\\Delta x_i \\leq \\epsilon$ 故可积\n[a,b]有限间断点有界证明可积  设间断点为b，M和m为上下确界，任给$\\epsilon\u0026gt;0$取$\\delta'=\\min { \\frac\\epsilon{2(M-m)} ,b-a}$ 记区间$\\Delta'=[b-\\delta',b]$振幅$\\omega'$则有 $$ \\omega'\\Delta x'\u0026lt;(M-m)\\frac\\epsilon{2(M-m)}=\\frac\\epsilon2 $$ $[a,b-\\delta']$连续故可积，在该区间存在某个分割T\u0026rsquo;使得$\\sum_T\\omega_i\\Delta x_i \u0026lt; \\epsilon/2$，加上$\\delta'$则有$\\sum_T\\omega_i\\Delta x_i \\leq \\epsilon$ 故可积  [a,b]单调有界证明可积  不妨设单增，划定从a到b的分割 $\\pi: a=x_0\u0026lt;x_1\u0026lt;\u0026hellip;\u0026lt;x_n=b$ 进行如下放缩  $$ \\begin{aligned} \\sum_{i=1}^n\\omega_i(x_i-x_{i-1})=\\sum_{i=1}^n(f(x_i)-f(x_{i-1}))(x_i-x_{i-1}) \\\\ \u0026lt;\\sum_{i=1}^n(f(b)-f(a))(x_i-x_{i-1})=(f(b)-f(a))||\\pi|| \\end{aligned} $$\n$\\forall \\epsilon\u0026gt;0, \\exists \\delta=\\frac{\\epsilon}{f(b)-f(a)}$ 使当$||\\pi||\u0026lt;\\delta$时原式$\u0026lt;\\epsilon$  几个值得注意的证明 证明$\\int_0^1f(x^2) \\leq f(\\frac13)$ 在$\\frac13$处泰勒展开，替换自变量，两边积分\n证明 $\\int_0^1|f''(x)|dx\u0026gt;4\\max_{x\\in[0,1]}|f(x)|, f(0)=f(1)=0$ 注意以下三点\n 左侧通过积分中值定理，右侧通过微分中值定理(最大值点)，共同靠向1阶 放缩时绝对值的积分大于等于积分的绝对值 右侧的4是由$\\frac{1}{x(1-x)}\\geq4$产生  证明 $(\\int_a^bf(x)g(x)dx)^2\\leq\\int_a^bf^2(x)dx\\int_a^bg^2(x)dx$ 设$F(x)=(\\int_a^xf(t)g(t)dt)^2-\\int_a^xf^2(t)dt\\int_a^xg^2(t)dt$，求导，平方和，代b\n[[数学分析-关于几何的积分]]\n","date":"2022-01-09T08:48:00+08:00","permalink":"http://atksoto.com/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E7%A7%AF%E5%88%86%E9%83%A8%E5%88%86%E8%AF%81%E6%98%8E/","title":"数学分析-积分部分证明"},{"content":"[[数据库系统原理期末复习]]\n绪论 数据库系统 独立性  物理独立性：物理改变，逻辑不变 逻辑独立性：逻辑改变，程序不变  完整性  数据正确性 相容性  三级模式两级映像   模式：全体数据的逻辑结构和特性\n  外模式：某一应用有关逻辑表示\n  内模式：数据物理结构和存储方式\n  外模式/模式映像——逻辑独立性\n  模式/内模式影响——物理独立性\n  数据控制  安全 完整 并发 恢复  数据模型 要素：\n 数据结构 数据操作 完整性约束  分类：\n 层次模型 网状模型 关系模型  DBMS 数据库系统建立在数据库管理系统DBMS之上\n功能  数据库定义 数据存取 数据库运行管理 数据组织和存储 数据库建立和维护  关系数据库 概念  码  候选码 主码   主属性 非主属性 关系模式 语义约束  实体完整性 参照完整性    代数运算 SQL    SQL关键字 含义     DISTINCT a 去除重复   BETWEEN a AND b 表示区间   ORDER BY a ASC/DESC 升降排序   GROUP BY a [HAVING \u0026hellip;] 分组    关系数据库理论 函数依赖 Armstrong 公理  自反 增广 传递  函数依赖闭包 $X_F^+$ X能推出的所有集合\n范式 1NF 每格只有一个值\n2NF 每个非主属性完全依赖于码\n3NF 每个非主属性不传递依赖于码\nBCNF 对于R的每个函数 依赖X-\u0026gt;Y，且Y$\\nsubseteq$X时，X必含有码\n 非主属性完全依赖于每个候选码 主属性完全依赖于不包含它的候选码 没有任何属性完全依赖于非码  规范化 求候选码 分为L，R，N，LR四类，L和N为主属性，不断加入LR中的一个属性，到能推出全集\n判断范式 看完非主属性是否完全依赖和传递依赖\n3NF的等价分解 保持函数依赖  极小化FD  拆右侧，去掉重复的 拆左侧，看是否还能推出右侧，决定是否取代 遍历一遍，看去掉后左侧还能否推出右侧，决定是否删除   不在F中出现的属性构成一个关系模式 如果有X-\u0026gt;A，XA直接构成全集，不能分解，算法终止 对F按照左边相同分组，分别把左右构成集合，删掉被包涵的  保持无损连接性与函数依赖 在保持函数依赖的基础上，加入码  无损分解判定 R1和R2的共有属性至少构成其中之一的候选码\n数据库设计 ER图 物理结构设计 数据库的存取：\n 索引存取 HASH存取 聚簇存取  关系查询处理与查询优化 连接操作的算法  嵌套循环 排序-合并 索引连接 Hash Join  查询处理  查询分析 查询检查 查询优化 查询执行  查询优化 分为代数优化和物理优化\n事务处理技术 事务 用户定义的操作序列，是数据库恢复和并发的基本单位\n特性：ACID\n 原子性 Atomicity 操作要么全做要么不做 一致性 Consistency 从一个一致性状态转移到另一个 隔离型 Isolation 并发执行互不干扰 持久性 Durability 一旦提交数据修改就是永久性的  事务故障恢复 UNDO  反向扫描日志 进行更新操作的逆操作  系统故障 UNDO+REDO  正向扫描日志，找到故障前已提交事务，加入REDO队列，未完成事务，加入UNDO队列 UNDO REDO  并发控制 合理调度事务，避免不一致\n封锁  排它锁 X 共享锁 S  封锁协议  一级：修改前加X锁，事务结束释放，防止丢失修改 二级：一级基础上读前加S锁，读完释放，防止读脏 三级：二级基础上，事务结束才释放，保证数据不可重复读  封锁粒度 多粒度封锁协议：对单个节点加锁则其后裔节点也加同类型的锁\n意向锁 该节点下层节点正在被加锁，对任意节点加锁时，必须对上级节点加意向锁。\n 意向共享锁（IS锁） 意向排它锁（IX锁） 意向共享排它锁（SIX锁）：加S锁，再加IX锁。  死锁 预防死锁  一次封锁法 顺序封锁法  检测死锁  超时法 等待图法  可串行性 并发执行与按某一次串行执行结果相同\n两端锁协议可以保证事务并发操作的正确性\n数据库保护  用户标识与鉴别 存取控制 审计功能 数据加密  存取控制方法  强制存取控制(MAC) 自主存取控制(DAC)  为维护完整性，DBMS应提供定义完整性约束条件的机制，提供完整性检查方法，具有违约响应\n分布式数据库 分布式数据库以数据分布为前提，强调场地自治性和场地之间的协作性\n分布透明性包括分片透明性，位置透明性，局部数据模型透明性\n全局查询是分布式数据库查询优化的主要对象\n连接查询优化技术：半连接\n分布式数据库系统中，通过全局模式和分片模式之间的映像实现分片透明性\n 判断范式：\n 只有2个属性——4NF 码由全部属性构成——3NF，BCNF 所有属性都是主属性——3NF，不一定BCNF  ","date":"2022-01-05T14:17:00+08:00","image":"https://pic.mcatk.com/soto/202201051418762.png","permalink":"http://atksoto.com/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/","title":"数据库-理论部分"},{"content":"下午两点半的游泳馆没有多少人，我成为了打破平静清澈水面的第一个人，耳边只有水的声音，不用想别的事情，得以享受片刻的宁静。\n很少在下午场来游泳馆，冬日午后的阳光温柔地打在水面上，把波光映在池底，是深水区独有的享受，水也比平日晚上来时暖和。穿过撒着阳光的水面，眼前一片闪亮，水下又是另一片安静的光晃动着。\n后从绿园散步回去，一路上没有什么人，也比平日安静几分，唯有穿过树林温柔的光，喝一瓶可乐，冬这个季节也不是一无是处了。\n","date":"2022-01-02T16:26:00+08:00","image":"https://pic.mcatk.com/soto/202201021637052.jpeg","permalink":"http://atksoto.com/%E5%86%AC%E6%97%A5%E7%9A%84%E5%85%89/","title":"冬日的光"},{"content":"新的一年。\n","date":"2022-01-01T01:33:00+08:00","permalink":"http://atksoto.com/%E4%BD%A0%E5%A5%BD2022/","title":"你好，2022"},{"content":"极坐标方程的积分 周长 $$ \\int_0^{2\\pi}r\\ d\\theta $$\n面积 $$ \\int_0^{2\\pi}\\frac{1}{2}r^2d\\theta $$\n弧长公式 一般形式 $$ s=\\int_a^b\\sqrt{1+y'^2}dx $$\n参数方程形式 $$ s=\\int_\\alpha^\\beta\\sqrt{x'^2(t)+y'^2(t)} $$\n极坐标形式 $$ s=\\int_\\alpha^\\beta\\sqrt{r^2(\\theta)+r'^2(\\theta)d\\theta} $$\n曲率公式 $$ k=\\frac{|y''|}{(1+(y')^2)^{\\frac{3}{2}}} $$\n特殊图形 双纽线1 $$ r^2 = 2a^2\\cos2\\theta $$\n星型线2 $$ \\begin{cases} x=a\\cos^3\\theta \\\\\ny=a\\sin^3\\theta \\end{cases} $$\n摆线3 $$ \\begin{cases} x=r(t-sin⁡t) \\\\ y=r(1−cos⁡t) \\end{cases} $$\n  https://zh.wikipedia.org/wiki/伯努利双纽线\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://zh.wikipedia.org/wiki/星形线\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://zh.wikipedia.org/wiki/摆线\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-12-30T22:26:00+08:00","permalink":"http://atksoto.com/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E5%85%B3%E4%BA%8E%E5%87%A0%E4%BD%95%E7%9A%84%E7%A7%AF%E5%88%86/","title":"数学分析-关于几何的积分"},{"content":"刚考完，趁着还记得题，留个记录，供参考。\n第一题：错误处理，增加constExp出现变量的错误\n第二题：代码生成，增加i++和i\u0026ndash;的文法，但是只出现在stmt里且只是变量++或\u0026ndash;\n第三题：直接交课下\n简答题：\nPCODE：\n描述一个函数调用时候运行栈\n描述多维数组的的定义和使用\n大体看了一眼mips的，是关于各种优化怎么实现的\n最后一题是竞速的，与我无关，没看\n 第一题，架构没做好，浪费不少时间，没想到会出现这种错误类型\n把所有分析表达式的函数参数加上一个isConst，然后在analyseConst里面加上true，其他地方false\n递归下降到Lval的时候，如果isConst并且这个ident是个变量，就报错\n第二题，直接在stmt的分析是赋值语句还是exp的位置拦截，如果exp（考场上试了我的getExp可以取出i++这样的表达式）是三位，直接看后两位是不是++和\u0026ndash;，如果是的话，首先analyseLval这个ident，然后生成一个新的exp，里面放入ident、+、1，analyseExp，然后pcode加上pop即可。\n第三个交了直接过了。\n简答题这部分，虽然我写了两页word，但是感觉关于运行栈我没讲得太清楚，毕竟pcode这个东西本来就是自由设计的，如果要说的很清楚也不是几句话能描述的，详细的都在[[Alxa_Compiler 编译器|文档]]里面了，希望助教能看一下。\n题出得挺好，这次评测机也没卡，体验不错，还有半个多小时出来的\n至此本学期的编译课程就全部结束了，完结撒花🎉\n","date":"2021-12-30T18:15:00+08:00","permalink":"http://atksoto.com/%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%AE%9E%E9%AA%8C%E6%9C%9F%E6%9C%AB%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95/","title":"关于编译实验期末上机考试"},{"content":"现在是凌晨1:26，刚水完领导力的报告，听着天空之城。\n今天(昨天)一早起来全朋友圈都在发自己的网易云，我于是打开了很久没有打开的Spotify，想看看有没有年度报告，尘封在资料库的李先生印入眼帘，点开了天空之城，顿时感觉非常感动，听了一下午他的歌。\n想想自己还挺喜欢他的歌的，却一直只能在Spotify听，于是到北邮人下了他的一堆专辑，打算导进AM。\n \n下载下来的文件是整个专辑完整的flac和cue文件\n \n这里用之前在少数派看到的XLD进行了一波转换。1\n这个软件真是让我非常惊喜，他不光可以转AM适用的无损和AAC，还可以轻易的使用cue切分。\n直接用XLD点开cue文件，把封面图拖上去，对没有正确识别的歌名稍作修改后点击Transcode即可。\n  AM的服务器在内地速度不是很好，因为我担心移动端同步过去播放卡的问题，我在这里生成了AAC（苹果的一种有损格式），每首歌就只剩下几mb了，直接拖进AM里即可。\n如果单曲的对应专辑出现问题，直接批量选择之后用AM自带的编辑功能稍作修改即可。\n \n \n 港岛妹妹，你献给我的西班牙馅饼\n甜蜜地融化了我，天空之城在哭泣\n港岛妹妹，我们曾拥有的甜蜜的爱情\n疯狂地撕裂了我，天空之城在哭泣\n  爱人 你可感到明天已经来临\n码头上停着我们的船\n我会洗干净头发爬上桅杆\n撑起我们葡萄枝嫩叶般的家\n   XLD：macOS 无损音频转换的不二之选 (https://sspai.com/post/56940)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-12-28T01:24:00+08:00","image":"https://pic.mcatk.com/soto/202112280125409.jpg","permalink":"http://atksoto.com/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E%E7%B1%B3%E5%BA%97%E5%92%8Cxld/","title":"天空之城，米店和XLD"},{"content":" \n \n \n考完编译的几天后，和朋友们在三里屯的一家烤肉店过了一个平安夜，因为外国人很多，这种气氛确实是之前没有感受到的，虽然听不懂他们的小游戏，和他们格格不入，但是一群人坐在一起，吃着烤肉喝着酒，戴着圣诞帽听着圣诞歌曲，大笑着玩小游戏，也是热闹非凡。\n圣诞节当天，和朋友去颐和园看冬至我没看到的金光穿十七孔桥桥洞。桥洞没我想象中那么“金”，反而是更关注当日耀眼的落日。\n \n \n \n \n今天真冷～\n","date":"2021-12-27T01:29:00+08:00","image":"https://pic.mcatk.com/soto/202112270145097.jpeg","permalink":"http://atksoto.com/%E5%9C%A3%E8%AF%9E%E5%92%8C%E9%A2%90%E5%92%8C%E5%9B%AD%E7%9A%84%E6%97%A5%E8%90%BD/","title":"圣诞和颐和园的日落"},{"content":"写这个[[关于Swift开发的依赖安装]]的时候回顾之前的[[IoTMonitor]]，突然很想推荐一下这个库，真的很好看，至少很符合我的审美。\n当时第一次试图在SwiftUI画图，搜遍全网没找到几个能用的，而且能用的也相当丑，踩了不少坑，终于跟着一个demo追根溯源找到了这个库，救我于水火之中。\n(说起来也是，写第一个SwiftUI APP的时候也一样，在网上找资料真的太艰难了，国内几乎没有多少人写这些东西)\n地址 https://github.com/AppPear/ChartView\n官方图例\n \n\n\n\n 好看就完了，另外使用也相当简单，两个例子：\nMultiLineChartView(data: [([8,32,11,23,40,28], GradientColors.green), ([90,99,78,111,70,60,77], GradientColors.purple), ([34,56,72,38,43,100,50], GradientColors.orngPink)], title: \u0026#34;Title\u0026#34;) \nPieChartView(data: [8,23,54,32], title: \u0026#34;Title\u0026#34;, legend: \u0026#34;Legendary\u0026#34;) // legend is optional  \n而且这些卡片样式都是可以自己重新修订的，不用担心和自己的风格不一样。比如我之前的这个直接搬了两个卡片上去，它的阴影和我其他没有阴影的卡片是很不和谐的，于是我稍作修改，把他改成了和我其他卡片样式风格一致的样子。\n \n因为之前开发仓促，使用的时候没有仔细修改样式，但是可以肯定这个库还有更多的发挥空间。总之这个库真的很不错，封装程度高又不失自定义的空间，推荐。\n","date":"2021-12-27T01:16:00+08:00","permalink":"http://atksoto.com/swiftui-%E5%9B%BE%E8%A1%A8%E5%BA%93-chartview/","title":"SwiftUI 图表库 ChartView"},{"content":"今天IOT课写报告突然要用到[[IoTMonitor]]，发现打开Xcode无法编译，找到原因是依赖SwiftHTTP出现了问题，缺少了其中的文件，鉴于之前直接下载了源文件拖进我的工程里，确实不是个规范操作方法，同时，之前做这个app遇到了各种新奇的依赖安装方式，于是决定重新规范安装一下，顺带记录。\nCocoaPods 这个应该是比较常用的方式？首先安装CocoaPods。在项目目录下创建Podfile文件，写入依赖所需的内容，例如\nsource 'https://github.com/CocoaPods/Specs.git' platform :ios, '8.0' use_frameworks! pod 'SwiftHTTP', '~\u0026gt; 3.0.1' 后 pod install\n虽然但是，我隐约记得我上次用这个方法搞不定。\nCarthage 这次我用了这个，首先用brew安装：brew install carthage\n在项目目录下创建Cartfile文件，写入依赖所需内容，如\ngithub \u0026quot;daltoniam/SwiftHTTP\u0026quot; \u0026gt;= 3.0.1 Run carthage update --use-xcframeworks\n进入生成的Carthage目录Carthage/Build，把.xcframework直接拖入项目的Frameworks区域即可。\nXcode 另外就是Xcode自带的装依赖方法了，一般如果依赖支持都会写操作步骤\n用ChartView举例\nFile → Add Packages\u0026hellip;\n搜索项目地址 https://github.com/AppPear/ChartView\n顺便推荐一下这个ChartView，真的很好看。\n \nAdd 即可\n","date":"2021-12-27T00:59:00+08:00","permalink":"http://atksoto.com/%E5%85%B3%E4%BA%8Eswift%E5%BC%80%E5%8F%91%E7%9A%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85/","title":"关于Swift开发的依赖安装"},{"content":"祝各位圣诞快乐\n先来点圣诞歌单\n uu们推荐的：\n Hail Chime On-Kate Rusby 无言花-萧敬腾 凤凰花开的路口-林志炫 没离开过-林志炫 单身情歌-林志炫 月亮惹的祸-张宇  还有我的私货：\n あの夢をなぞって-YOASOBI  ","date":"2021-12-24T23:42:00+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gxpctdc5yzj30rs0rsgp4.jpg","permalink":"http://atksoto.com/%E6%8E%A8%E6%AD%8C-%E7%AC%AC%E4%B8%89%E6%9C%9F/","title":"推歌 第三期"},{"content":"键值存储数据库与 Redis 键-值数据库，或键-值存储，是设计用来存储、检索和管理关联数组的数据存储范式，关联数组是现今更常称为“字典”或散列表的一种数据结构。字典包含对对象或记录的一个收集，依次、记录内有多个不同的“域”或称字段，再次、每个字段都包含数据。这些记录使用唯一标识这个记录的“键”来存储和检索，键还用来在数据库中快速的找到数据。1\n可以发现，键-值数据库的存储方式，更接近于现代面向对象的编程思维，同时，不同于关系数据库，键-值数据库通常可以使用更少的内存。限制键-值数据库的问题在于性能和标准化。\nRedis作为最为流行的键-值数据库，将在后文进行具体的调研。\nRedis是一个使用ANSI C编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。从2015年6月开始，Redis的开发由Redis Labs赞助，而2013年5月至2015年6月期间，其开发由Pivotal赞助。在2013年5月之前，其开发由VMware赞助。根据月度排行网站DB-Engines.com的数据，Redis是最流行的键值对存储数据库。2\n技术的产生背景 随着互联网和云计算的不断发展，各类应用层出不穷，对数据库技术提出了更高的要求，主要有以下几个方面：读写高并发低延迟、高效的大数据存储和访问需求、高可扩展性和高可用性、降低管理和运营成本。关系型数据库本身具有一定的逻辑复杂度，随着数据量的增加，容易带来死锁等并发问题，导致读写效率急剧下降；现有关系型数据库无法支持搜索引擎、SNS或Big System中的大数据；关系型数据库中存在的多表关联机制，成为影响数据库可扩展性的主要因素。3\n因此，出现了NoSQL，键-值数据库作为其中之一的数据模型，具有结构简单，查询速度快，支持更大的数据存储量和高并发性，支持通过主键进行数据的查询修改。\n基于目前大数据数据维度比较多，但是每一行数据的却并不是所有信息都具备的特点，其形成稀疏矩阵。如果采取过去的存储方式的话，将会浪费大量的空间，在存储时，需要将没有数据内容置空等。另外，在大数据时代，需求变化很快，造成数据模型（表结构）变化很快，数据库应该能够高效应对这种常态。键-值数据库可以很好的解决这些问题。\n技术的基本原理 键值对数据模型 键值对数据模型实是一个从键到值之间的映射。即key是査找每条数据地址的唯一关键字,value是该数据实际存储的内容。Key-Value数据模型典型的是采用哈希函数实现关键字到值的映射,表中有一个特定的Key和一个指针指向特定的Value。通过Key来定位Value，从而进行存储和检索，实现快速查询，并支持大数据量和髙并发查询。\n在键值对存储模式中，数据表中的每个实际行都具有行键（Key）和数值（Value）两个基本内容。值可以看作是一个单一的存储区域，可能是任何类型，甚至是数组。每个值都可能有不同的列名，不同键对应的值可能是完全不同的列。\n模型按照Key对数据进行快速的定位，可以通过对Key进行排序和分区操作，从而更快速的对数据定位。如果从Value入手的话，会造成资源浪费，要对全表的数据进行遍历查找。不适用于类似关系型数据库中的关联查询，实现的代码复杂且由于数据总量过于庞大，会导致查询效率低下。不会对Value进行索引，因为值对应的列是不确定的。在经过排序后的Key即可作为第一索引\n键值数据库可以划分为内存键值数据库和持久化键值数据库。内存键值数据库将数据保存在内存，持久化键值数据库将数据保存在磁盘。\nRedis 基本原理 Redis是一个开源的(BSD许可的)内存数据结构存储，用作数据库、缓存和消息代理。Redis提供数据结构，如字符串，哈希，列表，集，排序集，范围查询，位图，超日志，地理空间索引和流。Redis有内置的复制，Lua脚本，LRU驱逐，事务，和不同级别的磁盘上的持久性，并通过Redis Sentinel和Redis Cluster自动分区提供高可用性。4\nRedis 中重要的可执行文件  redis-server：Redis服务器程序 redis-cli：Redis客户端程序，它是一个命令行操作工具。也可以使用telnet根据其纯文本协议操作。 redis-benchmark：Redis性能测试工具，测试Redis在你的系统及配置下的读写性能。  Redis 内部模式 Redis内部实现采用epoll+自己实现的简单的事件框架。 epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性。Redis 服务采用I/O 多路复用的封装， Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）。\nRedis 线程模型 我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，IO事件分派器，依次去队列中取，转发到不同的事件处理器中。\nRedis 的数据类型  String hash list set sorted set  Redis 的过期策略以及内存淘汰机制 redis采用的是定期删除+惰性删除策略。定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。5\n技术的特点与应用场景 键值存储数据库特点  简洁。只涉及到增加和删除操作，不需要设计复杂的数据模型，也不需要为每个属性指定数据类型。动态添加时不需要修改原有数据库的定义 高速。不用将数据保存在内存中，在RAM中读取和写入速度要快很多，当然也可以选择持久化。因为是存在内存中，有时需要释放来存储新的数据，最常用的算法：LRU(Least Recently Used，最久未使用算法) 易于缩放。可缩放性：根据系统负载量，随时添加或删除服务器。  对于缩放，有两种方式：\n 主从式复制  主服务器处理写入请求和读取请求，并把数据复制到集群中的其他服务器里。从服务器只响应读取请求，遵从树形结构\n应用情况：希望服务器能快速相应查询请求，而对写入请求响应能力没有太多要求\n优点：简洁，其他服务器只需与主服务器通信，而且不用协调写入冲突\n缺点：主服务器作为独木桥，一旦故障，整个集群无法处理写入请求（解决：从服务器遵守协议，若主服务器故障，一台从服务器升为主服务器）\n无主式复制  对于诸如网上购票这种需要大量读取和写入请求的情况，主从不适合，采用无主式复制，它遵从一种环形或网状结构\n这种情况下每台服务器都可以吧自己活得新数据复制到其他服务器里面，可以指定哪几台作为它的副本存储服务器。\nRedis 特点  Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, 设置key有效期等等特性。  键值存储数据库与关系数据库的对比 Wittawat Puangsaijai等人对键值存储数据库与关系数据库进行的实验对比。\n通过对比作为键值数据库的NoSQL数据库Redis和关系数据库MariaDB的实验结果可以看出，NoSQL数据库在每次操作中并没有比关系数据库获得更高的性能。在对简单查询的单个结果进行查询和对复杂查询的数据进行查询时，Redis在插入操作、删除操作、更新操作尤其是使用特定条件进行更新、选择操作等方面具有较好的运行性能。因为Redis有很多优点，如灵活，没有固定的模式，易于使用。此外，MariaDB的数据模型更加复杂。因此，它降低了查询性能。然而，Redis在应用于大量数据的常规查询和更新方面也有缺点。因此，我们应该以临时数据库的形式使用Redis来提高数据库系统的性能。6\n应用场景 会话存储 一个面向会话的应用程序（如 Web 应用程序）在用户登录时启动会话，并保持活动状态直到用户注销或会话超时。在此期间，应用程序将所有与会话相关的数据存储在主内存或数据库中。会话数据可能包括用户资料信息、消息、个性化数据和主题、建议、有针对性的促销和折扣。每个用户会话具有唯一的标识符。除了主键之外，任何其他键都无法查询会话数据，因此快速键值存储更适合于会话数据。一般来说，键值数据库所提供的每页开销可能比关系数据库要小。\n购物车 在假日购物季，电子商务网站可能会在几秒钟内收到数十亿的订单。键值数据库可以处理大量数据扩展和极高的状态变化，同时通过分布式处理和存储为数百万并发用户提供服务。此外，键值数据库还具有内置冗余，可以处理丢失的存储节点。7\n缓存 缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。\n排行榜 很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。\n最新列表 Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。\n消息系统 消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。8\n  https://zh.wikipedia.org/wiki/%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://zh.wikipedia.org/wiki/Redis\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Jing Han, Haihong E, Guan Le and Jian Du, \u0026ldquo;Survey on NoSQL database,\u0026rdquo; 2011 6th International Conference on Pervasive Computing and Applications, 2011, pp. 363-366, doi: 10.1109/ICPCA.2011.6106531.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://redis.io/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://zhuanlan.zhihu.com/p/222697530\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n W. Puangsaijai and S. Puntheeranurak, \u0026ldquo;A comparative study of relational database and key-value database for big data applications,\u0026rdquo; 2017 International Electrical Engineering Congress (iEECON), 2017, pp. 1-4, doi: 10.1109/IEECON.2017.8075813.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://blog.csdn.net/LuckyChenH/article/details/107243149\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://segmentfault.com/a/1190000016188385\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-12-23T16:29:00+08:00","permalink":"http://atksoto.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A%E9%94%AE%E5%80%BCkey-value%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E-redis/","title":"数据库调研报告——键值(Key-Value)存储数据库与 Redis"},{"content":"[[TakeawayDelivery 后端实现]]\n项目展示视频\nweb端答辩PPT\n移动端APP答辩PPT\n项目前后端仓库\n移动端APP仓库\n","date":"2021-12-22T15:18:00+08:00","image":"https://pic.mcatk.com/soto/202112170131240.png","permalink":"http://atksoto.com/takeawaydelivery/","title":"关于TakeawayDelivery"},{"content":"编译原理 理论 考前再浏览一下目录\n 文法和语言  符号、符号串 文法形式定义  推导、规约 语言 递归   语法树、二义性 实用限制   词法分析  正则文法机状态图 有穷自动机   语法分析  自顶向下  LL(1)分析   自底向上  算符优先分析 LR语法分析     语法制导翻译  翻译文法   符号表 运行时存储  静态分配 动态分配 内存回收   中间代码  波兰表示、N元表示   错误处理 语义分析 代码优化  基本块和流图 基本块优化 全局优化   目标代码生成  寄存器分配     编译过程 典型的编译程序具有7个逻辑部分\n 词法分析 语法分析 语义分析、生成中间代码 代码优化 生成目标程序   符号表管理 出错处理  文法 推导 文法 $G=(V_n，V_t，P，Z)$\n巴科斯范式BNF规定是推导规则(产生式)的集合，写为：\n\u0026lt;符号\u0026gt; ::= \u0026lt;使用符号的表达式\u0026gt;\n如 E-\u0026gt;E+T|T 的扩充BNF表示为 E-\u0026gt;T{+T}\n $V_n: 非终结符号集$ $V_t:终结符号集$ $P:产生式或规则的集合$ $Z:开始符号(识别符号) Z \\in V_n$  句型 短语 句柄 句型是文法的某个推导\n 短语是前面句型中的某个非终结符所能推出的符号串。 任何句型本身一定是相对于识别符号Z的短语。 任一句型的最左简单短语称为该句型的句柄。 素短语，是指至少含有一个终结符的短语，并且除自身外，不包含更小的素短语。  从树的角度，直观的理解\n 短语：一个句型的语法树中任一子树叶结点所组成的符号串都是该句型的短语 简单短语：如果子树中不再包含其他的子树，即A只能推导出b，而b不能再推出其他的式子，则b为此句型的简单短语 句柄：最左直接短语为该句型的句柄  一个例子 文法G[E]为：\nE ::= RP|P\nP ::= (E)|i\nR ::= RP+ | RP* | P+ | P*\n上下文无关文法\n句型 (P+(i)) 的规范推导序列：\nE =\u0026gt;P=\u0026gt;(E)=\u0026gt;(RP)=\u0026gt;(R(E))=\u0026gt;(R(P)=\u0026gt;(R(i))=\u0026gt;(P+(i))\n语法树\n[[语法推导树.excalidraw]]  语法推导树 \n短语：(P+(i))，P+(i)，P+，(i)，i\n简单短语P＋, i\n句柄P+\nChomsky文法体系    文法 语言 自动机 产生式规则     0型 递归可枚举语言 图灵机 α -\u0026gt; β（无限制）   1型 上下文相关语言 线性有界非确定图灵机 α_A_β -\u0026gt; αγβ   2型 上下文无关语言 非确定下推自动机 A -\u0026gt; γ   3型 正则语言 有限状态自动机 A -\u0026gt; aB A -\u0026gt; a    二义性  不同的语法树 不同的规范推导 某规范句型句柄不唯一  文法的实用限制  有害规则 多余规则  不可达符号（始终用不到） 不活动符号（推不出任何终结符号）    词法 正则文法和状态图  右线性文法  形如： A → aB A → a 状态图：自上而下推导，需要一个终结状态，用终结符作为条件从左部非终结符指向右部非终结符   左线性文法  形如： A → Ba A → a 状态图: 自下而上规约，需要一个初始状态，然后从终态开始，箭头倒置，用终结符作为条件从右部非终结符指向左部非终结符 转换：用一个线性文法作状态图，再读出为另一个线性文法    例：\n \n右线性正则文法：\nS-\u0026gt;bU|aV U-\u0026gt;bZ V-\u0026gt;bZ Z-\u0026gt;aV Z-\u0026gt;$\\epsilon$\n左线性正则文法\nZ-\u0026gt;Ub|Vb|$\\epsilon$ V-\u0026gt;Za|a U-\u0026gt;b V-\u0026gt;a\n正则表达式与有穷自动机 DFA 确定的有穷自动机\n 确定的有穷自动机 \nNFA 不确定的有穷自动机\n$$ L(M') = {a^mb|m\\geq1}\\cup{ac^n|n\\geq 1}\\cup{ \\epsilon } $$\n 不确定的有穷自动机 \nNFA-\u0026gt;DFA-\u0026gt;最小DFA  先把正规式转换为 NFA（非确定有穷自动机） 再将 NFA 通过 \u0026ldquo;子集构造法\u0026rdquo; 转化为 DFA 最后将 DFA 通过 \u0026ldquo;分割法\u0026rdquo; 进行最小化  正规式转NFA  从正则生成NFA \n 例 \nNFA确定化  求初态闭包（能无条件滑动到的状态集合），作为第一个状态 将一个状态进行状态转移，求得到的状态的闭包的集合，作为新的状态  反复以上2步，遍历，得到所有状态\nDFA最小化  多余状态  本身不可达 不可到终态   根据以下两个条件判断等价  一致性条件。根据终态和非终态划分 蔓延性条件。对于所有输入符号，状态s和状态t必须转换到等价的状态里。    步骤：\n 分为终态和非终态 考察两个集合，集合中任意两个状态通过状态转变后是否同在终态和非终态，不是则分  语法 自顶向下 主要问题  左递归  消除直接左递归 改右递归   回溯  改写文法——提取 超前扫描    递归子程序法 即递归下降分析法，拆解成多个子程序分析\nLL(1)分析法 LL分析器是一种处理某些上下文无关文法自顶向下的分析器。因为它从左到右处理输入，再对句型执行最左推导出语法树\n一个 LL 分析器若被称为 LL(k) 分析器，表示它使用 k 个词法单元作向前探查\n求FIRST头符号和FOLLOW后继符号集\n画出LL1分析表，每个非终结符通过哪一个产生式生成终结符。对于右部存在$\\epsilon$的情况，则该产生式左部的FOLLOW集对应的终结符的位置都写上$\\epsilon$\n证明LL1文法：\n 上表每格产生式最多为1 若无$\\epsilon$，产生式右部FIRST集不相交（无共同头部） 若有$\\epsilon$，产生式右部FIRST集和产生式左部FOLLOW集不相交  分析过程：\n符号栈｜读入符号｜剩余输入串｜所用产生式\n自底向上 主要问题 句柄识别\n算符优先分析法 在算符文法中，任何一个规则右部都不存在两个非终结符相邻的情况。如 AB\n设有一个不含e规则的算符文法G，如果，任意两个终结符号对(a,b)在 ＜、＞和=（优先级）种关系中只有一种关系成立，则称G是算符优先文法，也称OPG文法。\n对于每个非终结符U（以下符号表示均不严谨，为个人理解）\nFIRSTVT(U) = {b|U-\u0026gt;b\u0026hellip; or U-\u0026gt;Vb\u0026hellip;}\nLASTVT(U) = {a|U-\u0026gt;\u0026hellip;a or U-\u0026gt;\u0026hellip;aV}\n对于某规则右部：\n \u0026hellip;aU\u0026hellip; 对所有b$\\in$FIRSTVT(U)有a$\u0026lt;$b (优先级) \u0026hellip;Ub\u0026hellip; 对所有a$\\in$LASTVT(U) 有a$\u0026gt;$b (优先级)  通俗理解，若ab可以同时规约，则优先级相同，若b需要后续导出，则b优先级高，若a需要后续导出，则a优先级高，但注意序不可改变。\n构造优先关系矩阵：\n 为每个非终结符 A 计算 FIRSTVT(A) 和 LASTVT(A) 逐条扫描文法规则 例如+T 则 +\u0026lt; FIRSTVT(T)，E+ 则 LASTVT(E)\u0026gt;+ 寻找#与开始符号E的关系 # = # ， # \u0026lt;FIRSTVT(E)且LASTVT(E)\u0026gt; #  分析过程：\n符号栈｜剩余输入串｜优先关系｜动作(移进/规约)\nLR分析法 类似LL，R指分析过程是最右(Right)推导的逆过程(规范归约)\n活前缀: 若分析过程能够保证栈中符号串均是规范句型 的前缀，则表示输入串已分析过的部分没有语 法错误，所以称为规范句型的活前缀。\n对于句型αβt， β表示句柄,如果αβ= u1u2\u0026hellip;ur 那么符号串u1u2\u0026hellip;ui(1≤i≤r)即是句型αβt的活前缀\nLR分析过程：\n 拓广文法  头部E' -\u0026gt; E 对形如A-\u0026gt;B|C，拆解为A-\u0026gt;B和A-\u0026gt;C两条规则   写出项目集规范族  从 E' -\u0026gt; E 开始 求其闭包作为一个状态，“点”右移一位需要的符号作为状态转移符号 反复求状态   写出非终结符FIRST和FOLLOW集 画出GOTO和ACTION表  每个状态根据上一步骤得到的状态转移符号写上Sx 意为状态转移 若状态中的产生式“点”抵达结尾，则对于该产生式左部非终结符FOLLOW集中的终结符对应的格子写上rx，意为按某产生式规约    分析过程：\n状态栈｜符号｜输入串｜动作(S/rx)\n语法制导 翻译文法  插入动作符号的文法。 翻译文法是上下文无关文法（2型文法）。 终结符号集由输入符号和动作符号组成。 由翻译文法可以通过推导产生活动序列。由翻译文法所产生的终结符号串称为活动序列。  动作序列：带着@推导得到的序列\n输出序列：每个@后的字符的序列\n属性翻译文法 ↓继承属性 ↑综合属性\nL-ATG 转换为 SL-ATG\n考虑产生式：\n\u0026lt; A \u0026gt; → a↑R \u0026lt; B \u0026gt;↑S \u0026lt; C \u0026gt;↓I，I := f(R , S)\n设动作符号“@ f ” 表示函数 f 求值，该动作符号有两个继承属性和一个综合属性。\n@f↓I1,I2↑S1 S1 := f(I1, I2)\n修改产生式\n插入“@ f ” 到右部的适当位置，引进新的复写规则（将R，S 赋给 I1 和 I2，f 值赋给 S1），删去原有包含 f 的规则 \u0026lt; A \u0026gt; → a↑R \u0026lt; B \u0026gt;↑S @ f↓I1,I2↑S1 \u0026lt; C \u0026gt;↓I，I1 := R，I2 := S，S1 := f( I1, I2)，I := S1\n该文法是简单赋值形式的L-ATG。\n动态存储分配 活动记录 AR(Activation Record )：当进入一个程序模块时，在运行栈内创建的专用数据区\n   活动记录     参数区域   display区   局部数据区     局部数据区 参数区域  隐式参数  一个返回地址 一个指向前一个AR的指针prevabp 一个返回值   显式参数   display区  全局指向其他活动记录的指针    代码优化 基本块内优化 基本块：只能从入口进入出口离开，根据跳转划分\nDAG图 画出DAG图，重新导出代码序列\n其中，没有初始化的变量可以用下标0来标注\n通过构建DAG图消除公共子表达式  初始化一个节点表 从第一条指令开始  若为 z=x op y，若不存在节点x和y，则创建节点x和y，在节点表标注x和y的节点序号。根据op创建新的节点作为前两个节点的父节点，节点表给z标注该节点序号。注意新的标注要覆盖原来的。 若为z=x则直接让给z标注为x的节点。   重复，遍历指令   示例 \n从DAG图导出中间代码的启发式算法  初始化一个队列 找到一个父节点不在队列或者没有父节点的节点，加入队列 查看该节点的最左子节点，若父节点都在队列，则加入队列，然后查看最左子节点的子节点，若不满足条件，重新做2 重复，遍历所有节点 逆序输出，则得到中间节点的计算顺序，写出新的代码序列   上述示例的结果 \n窥孔优化 删除一小段内的冗余指令\n全局优化 数据流分析 到达定义数据流分析 强调一条语句\n 写出每个基本块的gen和kill 根据下述公式计算每个基本块的out，其中in为前驱的out  $$out[B] = gen[B]\\cup(in[B]-kill[B])$$\n反复操作，直到out不再变   gen：块中定义变量的语句 kill：消灭（给其重新赋值）了其他块中定义变量的语句  活跃变量分析 强调变量本身\n 写出每个基本块的def和use 根据下述公式计算每个基本块的in，其中out为后驱的in  $$in[B] = use[B]\\cup(out[B]-def[B])$$\n反复操作，直到in不再变   def：定义先于使用的变量 use：使用先于定义的变量  对于在多个基本块之间传递，持续活跃的，可以作出变量冲突图\n若一个变量在另一个变量活跃处定义则冲突\n寄存器分配 引用计数 根据变量的引用次数排序分配寄存器，给在循环中的变量加上一个与层数有关的权值。\n图着色算法 构建冲突图 参考活跃变量分析\n图着色算法 寄存器数量K，对应K个颜色\n 取出1个边小于K的节点，移走，记录，重复，直到剩1个。若无法移，任选一个点作为无法着色点移除再重新操作。 按照刚才移走的逆序为节点着色，相邻节点不能为同一颜色。  ","date":"2021-12-15T10:11:00+08:00","image":"https://pic.mcatk.com/soto/202112202258896.png","permalink":"http://atksoto.com/buaa-compiler-theory/","title":"编译原理-理论部分"},{"content":"现在已经是13号了，时间过得真快，来不及展望，今年就要过完了。\n今天终于截止了数据库和安卓的大作业，虽然有遇到一些不愉快，终于都结束了。\n这是第15周，从上周开始已经基本没什么课了，后续就是一大堆考试，这应该是我考试最多的一个学期了吧。\n 15周日程 \n昨天临时起意去景山公园，4点出发，天气好，一路在赶着希望能见一面夕阳，路过北海，被余晖吸引，就下了车，先冲到北海公园，逛公园真是惬意。\n \n \n \n \n随后也没丢了景山，虽然抵达时已经天黑得连路都看不清，最后也抵达了万春亭，俯瞰了一眼故宫。\n \n 故宫 \n","date":"2021-12-13T00:37:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/R6dzgZ.jpeg","permalink":"http://atksoto.com/%E5%B1%95%E6%9C%9B%E4%B8%80%E4%B8%8B%E5%8D%81%E4%BA%8C%E6%9C%88/","title":"展望一下十二月"},{"content":"昨天听说出个很厉害的漏洞，是Java使用Apacje的log框架的问题，可以执行任何命令，问题很严重，不说涉及到全部MC服务器，连TX都受影响，一方面因为暂时不好解决，也因为这个漏洞严重到小服不会成为首要攻击目标，于是也没有在意。\n今天很快各个服务端开始推出带补丁的新版本，Spigot也是，甚至在MCBBS论坛看到了之前写安全插件的一个眼熟的大佬给了一个参数解决问题的方法，佩服众大佬和互联网的速度。我已经去构建了一下新版的Spigot，并且加上了那个参数，双重保险目前应该没有问题了，尽管到现在我还不知道具体怎么触发这个漏洞。\n昨天看kotlin，一时兴起重写了GuildManager这个一年前初学Java时留下的ss代码，回头看看发现这个插件也记录着自己这一年来编程能力的进步，从面向对象，到数据库设计，也算是学以致用了，想想如果初中的时候自己尝试一下学习这些东西，或许也能少吃点当时折腾MC时候不懂编程的苦头。\n 迁移到数据库 \n发展快呀。\n","date":"2021-12-10T22:23:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/0tqH35.png","permalink":"http://atksoto.com/%E6%9C%80%E8%BF%91%E7%9A%84log4j-%E5%92%8C%E6%96%B0%E7%9A%84-guildmanager/","title":"最近的log4j 和新的 GuildManager"},{"content":"TakeawayDelivery 后端实现 开发环境  Python Django PyTorch MySQL  云端部署 我们将后端Django和数据库均部署在服务器上，并且进行了域名解析，可以通过delivery.mcatk.com直接访问后端，前端可以在任意情况下发送请求。\n服务器供应：腾讯云\u0026amp;阿里云 服务器系统：CentOS 7 数据库：MySQL 5 解释器：Anaconda 3\n数据库结构  数据库结构 \n后端实现接口 path(\u0026#39;api/login/\u0026#39;, myapp.views.login), path(\u0026#39;api/register/\u0026#39;, myapp.views.register), path(\u0026#39;api/getInformation/\u0026#39;, myapp.views.get_information), path(\u0026#39;api/changeInformation/\u0026#39;, myapp.views.change_information), path(\u0026#39;api/changePassword/\u0026#39;, myapp.views.change_password), path(\u0026#39;api/getStores/\u0026#39;, myapp.views.get_stores), path(\u0026#39;api/getStoreInformation/\u0026#39;, myapp.views.get_store_information), path(\u0026#39;api/deleteUser/\u0026#39;, myapp.views.delete_user), path(\u0026#39;api/getEvaluateFood/\u0026#39;, myapp.views.get_evaluate_food), path(\u0026#39;api/evaluateFood/\u0026#39;, myapp.views.evaluate_food), path(\u0026#39;api/deleteEvaluateFood/\u0026#39;, myapp.views.delete_evaluate_food), path(\u0026#39;api/getEvaluateUser/\u0026#39;, myapp.views.get_evaluate_user), path(\u0026#39;api/evaluateUser/\u0026#39;, myapp.views.evaluate_user), path(\u0026#39;api/deleteEvaluateUser/\u0026#39;, myapp.views.delete_evaluate_user), path(\u0026#39;api/setOrders/\u0026#39;, myapp.views.set_orders), path(\u0026#39;api/unStar/\u0026#39;, myapp.views.un_star), path(\u0026#39;api/setStar/\u0026#39;, myapp.views.set_star), path(\u0026#39;api/finishOrder/\u0026#39;, myapp.views.finish_order), path(\u0026#39;api/takeOrder/\u0026#39;, myapp.views.take_order), path(\u0026#39;api/getAllOrders/\u0026#39;, myapp.views.get_all_orders), path(\u0026#39;api/getTopFoodList/\u0026#39;, myapp.views.get_top_food_list), path(\u0026#39;api/androidGetUserFoodEvaluate/\u0026#39;, myapp.views.android_get_user_food_evaluate), path(\u0026#39;api/androidGetFoodEvaluateScore/\u0026#39;, myapp.views.android_get_food_evaluate_score), 深度学习 我们根据订单的配送时间是星期几，餐厅，配送地等信息通过深度学习预测订单送达时间 我们通过手动构造数据集，训练了一个模型存到服务器，并在每次前端发送新的请求后对订单进行预计送达时间的计算。\n \ndef predict(model,dl): model.eval() with torch.no_grad(): result = model(torch.FloatTensor(dl)) return(result.item()*65.0) ORM 我们通过Django ORM生成了数据表对象的models，方便了数据库的操作，例如\nFood\n Food \n实现为\nclass Food(models.Model): food_id = models.AutoField(primary_key=True) food_name = models.CharField(max_length=100, blank=True, null=True) food_price = models.DecimalField(max_digits=10, decimal_places=2, blank=True, null=True) food_url = models.CharField(max_length=500, blank=True, null=True) food_type = models.CharField(max_length=100, blank=True, null=True) store = models.ForeignKey(\u0026#39;Store\u0026#39;, models.DO_NOTHING, blank=True, null=True) class Meta: managed = False db_table = \u0026#39;food\u0026#39; 实现样例  【增】用户注册  前端发送post请求 URL: http://delivery.mcatk.com/api/register/ PARA: userName userPassword userNickname userTel userAddress\n后端接到请求，执行register\ndef register(request): if request.method == \u0026#34;POST\u0026#34;: data_json = json.loads(request.body) new_name = data_json.get(\u0026#34;userName\u0026#34;) new_pwd = make_password(data_json.get(\u0026#34;userPassword\u0026#34;)) new_nickname = data_json.get(\u0026#34;userNickname\u0026#34;) new_tel = data_json.get(\u0026#34;userTel\u0026#34;) new_address = data_json.get(\u0026#34;userAddress\u0026#34;) if new_name is None: return JsonResponse({\u0026#34;success\u0026#34;: False, \u0026#34;message\u0026#34;: \u0026#34;未输入\u0026#34;}) else: space = User.objects.filter(user_name=new_name) if len(space) \u0026gt; 0: return JsonResponse({\u0026#34;success\u0026#34;: False, \u0026#34;message\u0026#34;: \u0026#34;用户名已存在\u0026#34;}) else: new_user = User() new_user.user_name = new_name new_user.user_password = new_pwd new_user.user_nickname = new_nickname new_user.user_tel = new_tel new_user.user_address = new_address new_user.user_icon_url = \u0026#34;https://img0.baidu.com/it/u=3730772664,138405132\u0026amp;fm=26\u0026amp;fmt=auto\u0026#34; new_user.save() return JsonResponse({\u0026#34;success\u0026#34;: True, \u0026#34;message\u0026#34;: \u0026#34;注册成功\u0026#34;, \u0026#34;userID\u0026#34;: new_user.user_id}) else: JsonResponse({\u0026#34;success\u0026#34;: False, \u0026#34;message\u0026#34;: \u0026#34;请求异常\u0026#34;}) 先检查是否有重名用户，若无，通过Django ORM 将新生成的User导入数据库。\n【删】用户注销  前端发送post请求 URL: http://delivery.mcatk.com/api/deleteUser/ PARA: userID userPassword\ndef delete_user(request): if request.method == \u0026#34;POST\u0026#34;: data_json = json.loads(request.body) user_id = data_json.get(\u0026#34;userID\u0026#34;) password = data_json.get(\u0026#34;userPassword\u0026#34;) user = User.objects.get(user_id=user_id) if check_password(password, user.user_password): user.delete() return JsonResponse({\u0026#34;success\u0026#34;: True, \u0026#34;message\u0026#34;: \u0026#34;注销成功\u0026#34;}) else: return JsonResponse({\u0026#34;success\u0026#34;: False, \u0026#34;message\u0026#34;: \u0026#34;密码错误\u0026#34;}) 检查密码是否正确，若正确则注销用户\n【改】完成订单  以完成订单为例\n前端发送post请求 URL: http://delivery.mcatk.com/api/finishOrder/ PARA: orderID\ndef finish_order(request): if request.method == \u0026#34;POST\u0026#34;: data_json = json.loads(request.body) order_id = data_json.get(\u0026#34;orderID\u0026#34;) Order.objects.filter(order_id=order_id).update(order_completed=2) return JsonResponse({\u0026#34;success\u0026#34;: True, \u0026#34;message\u0026#34;: \u0026#34;配送完成\u0026#34;, }) else: JsonResponse({\u0026#34;success\u0026#34;: False, \u0026#34;message\u0026#34;: \u0026#34;请求异常\u0026#34;}) 用户信息查询  用前端向后端发送获取用户全部信息的API为例\n前端发送post请求 URL: http://delivery.mcatk.com/api/getInformation/ PARA: userID\n后端接到请求，执行get_information\ndef get_information(request): if request.method == \u0026#34;POST\u0026#34;: data_json = json.loads(request.body) user_id = data_json.get(\u0026#34;userID\u0026#34;) user = User.objects.get(user_id=user_id) orders1 = get_orders(user, False) orders2 = get_orders(user, True) stars = get_stars(user) return JsonResponse({\u0026#34;success\u0026#34;: True, \u0026#34;message\u0026#34;: \u0026#34;查询成功\u0026#34;, \u0026#34;userName\u0026#34;: user.user_name, \u0026#34;userNickName\u0026#34;: user.user_nickname, \u0026#34;userAddress\u0026#34;: user.user_address, \u0026#34;userTel\u0026#34;: user.user_tel, \u0026#34;userOrders\u0026#34;: orders1, \u0026#34;userDeliveryOrders\u0026#34;: orders2, \u0026#34;userStars\u0026#34;: stars, \u0026#34;userIconUrl\u0026#34;: user.user_icon_url, }) else: JsonResponse({\u0026#34;success\u0026#34;: False, \u0026#34;message\u0026#34;: \u0026#34;请求异常\u0026#34;}) 此过程还会调用获取用户订单和用户收藏以及机器学习的函数，不具体展出\n随后，前端可以得到类似如下的返回\n{ \u0026#34;success\u0026#34;: true, \u0026#34;message\u0026#34;: \u0026#34;查询成功\u0026#34;, \u0026#34;userName\u0026#34;: \u0026#34;zzh\u0026#34;, \u0026#34;userNickName\u0026#34;: \u0026#34;粥童帆\u0026#34;, \u0026#34;userAddress\u0026#34;: \u0026#34;学院路-15公寓\u0026#34;, \u0026#34;userTel\u0026#34;: \u0026#34;18800130501\u0026#34;, \u0026#34;userOrders\u0026#34;: [ ... } 这样我们就完成了前后端的通信\n密码加密 我们对数据库的密码进行了加密，通过Django的 make_password() 和 check_password() 函数在传入和验证密码时候进行了加密解密操作。\n 数据库中加密的密码 \n同时，由于我们的系统起初上线时密码为明文存储，我们会在老用户第一次登陆时通过其验证并为其加密。\nif user.user_password == password: user.user_password = make_password(password) user.save() return JsonResponse({\u0026#34;success\u0026#34;: True, \u0026#34;message\u0026#34;: \u0026#34;登录成功，已为您的密码加密\u0026#34;, \u0026#34;userID\u0026#34;: user.user_id}) elif check_password(password, user.user_password): return JsonResponse({\u0026#34;success\u0026#34;: True, \u0026#34;message\u0026#34;: \u0026#34;登录成功\u0026#34;, \u0026#34;userID\u0026#34;: user.user_id}) 设计细节 热菜推荐 我们通过MySQL的特性，统计出在订单-菜品关系表中出现最多的菜品，向用户推荐热门菜品。\norder_foods = OrderFood.objects.values(\u0026#39;food_id\u0026#39;).annotate(sum=Sum(\u0026#39;food_num\u0026#39;)).order_by(\u0026#39;-sum\u0026#39;) for order_food in order_foods: food = Food.objects.get(food_id=order_food.get(\u0026#39;food_id\u0026#39;)) food_json = get_food_json(food, True) food_json[\u0026#34;sum\u0026#34;] = order_food.get(\u0026#39;sum\u0026#39;) food_list.append(food_json) 按时间展示 我们在展示订单，评论等时候会按照时间先后展示，更加人性化\nfood_evaluates = FoodEvaluate.objects.filter(food_id=food_id).order_by(\u0026#34;-food_evaluate_date\u0026#34;) 下单\u0026amp;送单 由于我们的开发APP的初衷就是任何用户都可以下单，也可以送单，因此我们提供了返回自己下的单和自己接的单，还有等待接的单的API，他们都根据你的角色不同，返回不同的的结构类型，例如，当你查看自己的单，数据重点在于你点的菜品和价格等，而当你查看你可以接的单时，数据的重点在于这个订单是从哪里送到哪里等等，为此我们提供了各式各样的查询API。\n数据完整性 我们为所有存在关系的对象增加了外键约束，并且加入了 MySQL on delete cascade 的删除规则，在对象删除时删除与其有外键约束的对象。\n例如，当我们删除一个用户的时候，他的全部订单，订单中的菜品关系，用户收藏等将被一并删除，不会出现数据异常。\n","date":"2021-12-07T19:14:00+08:00","image":"https://pic.mcatk.com/soto/202112170131240.png","permalink":"http://atksoto.com/takeawaydelivery-back/","title":"TakeawayDelivery 后端实现"},{"content":"最近在玩Hexo1，加上很多零散的笔记和文档也是markdown写的，发现自己用markdown的频率高了很多。本来就在计划换一个效率更高的markdown编辑器，毕竟确实有很多markdown的场景是单个编辑器没法覆盖的，Typora2现在也收费了，趁着这个契机，打算换一个软件用。\n听说 all in one 的 Notion3 很好使，身边也有人在用，于是先试了一下，发现首先这个东西已经不是传统的markdown了，有点趋近于word那种富文本，并且云端依赖太高了，我要求得有一套本地可以用来渲染的md文件，所以没法用这个。\n另外就是一直感觉很神秘但是不会用的Obsidian4。由于习惯停留在Typora，刚下载下来Obsidian感觉非常不习惯，没法直接打开一个md，而且没法实时预览。\n但是经过一番研究之后，发现Obsidian确实是很适合我的需求。\n主题 首先Obsidian的社区非常丰富，有很多非常好看的主题，换上之后感觉比之前typora的打字体验好了很多。\n 社区主题 \n推荐一个 YIN \u0026amp; YANG 5 我现在在用，很好看。\n而且主题，包括插件加完之后就是多端同步的，连手机上也有。\n插件 还是因为社区文化好，插件也很多，但是目前我没什么需要的，唯一装了一个模板插件，可以用快捷键生成我预置的内容，这个和Hexo配合起来非常舒服，之前为了让md生成FrontMatter，必须手动hexo n，现在只要提前设置好Hexo的FrontMatter，设置好快捷键，即可一键生成需要的内容，包括时间这种变量。\n如下，我设置好模板后，只需 command+T 即可生成下面的内容\n--- title: \u0026lt;% tp.file.title %\u0026gt; date: \u0026lt;% tp.file.creation_date() %\u0026gt;:00 tags: [] image: --- --- title: Obsidian体验——新工作流 date: 2021-12-07 12:11:00 tags: [] image: --- 插件名：Templater\n双链 这个双向链接，指的就是你的一个md对象可以指向另一个对象，然后目标对象也会知道有哪个对象指向了自己。我理解这个东西就是类似于一个图，模拟你的神经网络，形成一种你的第二大脑的感觉，但其实到现在我也没感觉到有多强大，没有get到他的点。\n这是他给我的仓库生成的图谱，因为没怎么建双链，所以边比较少，倒是挺好玩\n 关系图谱 \n不过标签和查找功能倒是感觉很好用，我之前给hexo写的标签他也很好的解析下来了，在我真正写笔记的时候，可以非常方便的查到我需要的东西。\n 我写笔记的时候 \n同步 Obsidian很好的一点是可以用iCloud同步，这是我之前的需求：云同步编辑markdowndo的最好的解决方案。\nObsidian有iOS端，而且非常轻量，此时此刻这段话就是我在手机上打下的（但是汉字输入法适配不太好）\n在这个情况下，我把所有的笔记都放到一个仓库里，标签和双链让他们相互关联，在任何设备上都可以看到，很好的保证了整体性，而我又可以分开哪些是要发布的哪些是不发布的。\n图片处理 Obsidian不同于Typora的一点是图片不是很好处理，Obsidian的方法是把你放进来的图片复制到库目录下，然后加上双链。其实这也不是软件的问题，md格式本身就对图片本地加载不是很友好，加上我要上传到博客，整个目录会非常凌乱。同时我想要遵循数据方便转移的原则，以便在之后出现任何问题，我的原数据都整齐保留，于是我用阿里云对象存储OSS建了一个图床，同时使用CDN加速。\n同时使用uPic6（picgo7也很好）这个软件，在写笔记的时候，只需要用快捷键上传图片，即可马上拿到图片的链接，以后就不会再在笔记里放上一堆杂乱的图片了，发布到Github Pages的时候也会快很多。\n日记 这个东西甚至可以记日记，有专门的日记系统，还有配套的日历插件，尝试了一下体验确实不错，这是我曾经有过的需求。\n官方介绍：4\n 正如其名，当你使用日记功能时，Obsidian 会为你创建一篇以当天日期命名的空白笔记。当然，如果这篇笔记已经存在了的话，Obsidian 则会为你打开它。日记功能就是为了让你更方便地记录日常生活而设计的，你可以在每天的日记中写下你的生活记录、待办事项，抑或是当天的笔记总结，等等。日记功能允许你为日记指定模板，这样你就不需要重复调整日记的格式。\n  日记效果 \n用双链和以前的自己对话，也是很有趣的一件事情。\n用双链看那年今日，也是个非常好的选择（加上双链到电影和书籍，完爆某Memo（？））\n新的工作流 倒也谈不上什么工作流，可能是少数派看多了，只是觉得折腾好玩。\n以下是我现在发布博客的过程，非常简单\n 打开Obsidian，新建文件，输入标题，cmd+T 生成FrontMatter 写 打开控制台，输入hexos  解释一下最后一步 我在本地建立了一个全局脚本hexos（[[MacOS全局可执行文件]])\n内容如下\n1 #!/bin/bash 2 rm -rf /Users/soto/Documents/HexoBlog/source/_posts 3 cp -r /Users/soto/Library/Mobile\\ Documents/iCloud\\~md\\~obsidian/Documents/\u0026gt; 笔记/HexoBlog /Users/soto/Documents/HexoBlog/source/_posts 4 cd /Users/soto/Documents/HexoBlog 5 hexo g 6 hexo d 其过程为\n 删除hexo下的posts 把obsidian目录下的文件夹复制到hexo的posts 生成，部署  这样做的好处是分离hexo目录和真正的笔记，我把笔记目录放到了iCloud上，以便在任何设备上直接用obsidian打开仓库，不需要把hexo上传到iCloud，就不用担心Obsidian只能打开整个hexo目录的问题\n  Hexo: https://hexo.io/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Typora: https://www.typora.io\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Notion: https://www.notion.so\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Obsidian: https://obsidian.md\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Obsidian主题Yin-and-Yang: https://github.com/chetachiezikeuzor/Yin-and-Yang-Theme\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n uPic: https://github.com/gee1k/uPic\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n PicGo: https://github.com/Molunerfinn/PicGo\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-12-07T12:11:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/XmECh3.png","permalink":"http://atksoto.com/obsidian%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%96%B0%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"Obsidian体验与新工作流"},{"content":"第一次作业—巴洛克时期的音乐  巴洛克时期的旋律有什么特点？  旋律具大量装饰音 速度不变 在一个调性上表达情感\n巴洛克时期的节奏、节拍有什么独特之处？  规律\n巴洛克时期的音乐速度有对比吗？  速度不变\n巴洛克时期的音阶有哪两种？  大调小调\n你能说出欧洲的大调音阶与和声小调音阶吗？  大调12345671\n小调671234#56\n巴洛克时期的和声有什么特点？  主调音乐，复调音乐\n 什么是通奏低音？什么是数字低音？ 通奏低音（Basso continuo）是巴洛克时期的一种即兴伴奏声部，通奏低音演奏者阅读作曲家以数字低音写成的乐谱，并判断和即兴演奏。一般来说，通奏低音声部由两件乐器演奏，一件是低音乐器，另一件是和声乐器。 巴洛克时期的室内乐作品中羽管键琴总是被用来担任通奏低音\n  作曲家什么时期开始在乐谱上标注力度记号了？\n  巴洛克\n巴洛克时期的音乐风格特点是什么？  悠长而富于装饰的旋律线条\n大量华丽的装饰音（波光粼粼的装饰音）\n速度不变\n在一个调性上表达情感\n节拍规律\n西方交响乐队唯一的一件中国乐器是哪一件？  锣\n交响乐队弦乐组：高音乐器、中音乐器、低音乐器分别是哪一件？  [[交响乐队配置]]\n交响乐队木管乐器组：高音乐器、中音乐器、低音乐器分别是哪一件？  [[交响乐队配置]]\n交响乐队铜管乐器组：高音乐器、中音乐器、低音乐器分别是哪一件？  [[交响乐队配置]]\n小型、中型、大型乐队分别是多少人？  [[交响乐队配置]]\n什么是咏叹调？宣叙调？它们在歌剧中的作用？  歌剧有两种传统的演唱形式：宣叙调（recitativo），不带旋律结构的演唱部分，通常用于交代剧情；咏叹调（aria），通常用于表达角色感情，带旋律结构的唱段。\n复调音乐听旋律的线条，主调听纵向的和声，这句话对吗？  复调音乐听线条 主调音乐听纵向和声\n第二次作业— 维也纳古典时期的音乐  古典三杰指的是哪三位作曲家？  海顿，莫扎特，贝多芬\n维也纳古典时期的作曲家创作的音乐属于纯音乐还是标题音乐？  纯音乐\n维也纳古典风格最突出的音乐特点是什么？  简洁方正\n巴洛克时期与维也纳古典时期的音乐旋律有什么不同？  巴洛克时期旋律具大量装饰音，速度不变，在一个调性上表达情感\n维也纳古典时期旋律简洁方正，速度有对比\n弦乐四重奏的四件乐器是哪四件？  通常是2把小提琴，一把中提琴和一把大提琴。\n羽管键琴与钢琴（pianoforte）有什么不同？  大键琴发音原理与钢琴不同，前者类似弦乐的拨弦方式，后者是敲击的方式。所以发音方式不同、音色不同。至于音量的部分，钢琴的音量比较大；大键琴则比较少。大键琴拨弦和现代钢琴敲击的方式造成声音的泛音也会有所不同。大键琴的泛音比较不持久，不像钢琴的音比较饱满。不过由于有些钢琴的音过于饱满，构成对一些巴洛克音乐的表现上不尽完美。此外，大键琴发出的谐波的部分远超出钢琴\n协奏曲的第一乐章和交响曲的第一乐章在结构上有什么不同？  维也纳古典时期交响曲和协奏曲第一乐章都用奏鸣曲式快板，但这时期的协奏曲用双呈示部。\n交响曲、协奏曲、奏鸣曲、歌剧序曲哪种音乐体裁属于套曲形式？  套曲形式：乐章：协奏3 奏鸣4 弦乐四重奏4 交响曲4\n维也纳古典时期—意大利喜歌剧有什么创作特点？  特点：序曲：奏鸣式快板，急口令——喜歌剧独有，引入多部声乐重唱，羽管键琴为宣叙调伴奏\n维也纳古典时期产生了什么曲式结构？  奏鸣曲式快板\n第三次作业—浪漫主义时期的音乐风格  浪漫主义时期旋律、和声、速度、力度的特点？  旋律悠长（多用半音 具不确定性）\n和声 建立半音和声\n自由速度 tempo rubato\n力度强烈 极致的强与弱\n浪漫主义时期调式、调性、曲式结构的特点？  调式调性 转调离调变化频繁\n曲式结构自由\n浪漫主义时期交响乐队的特点？  老乐器的进步，新乐器的诞生，浪漫晚期到达四管编制，乐队更加庞大发出世纪最响的声音。\n什么时期产生了专业的指挥家？  浪漫主义时期\n艺术歌曲的三个特点是什么？  主要采用诗人诗作\n钢琴：伴奏烘托\n歌唱：意大利美声\n音乐会序曲和歌剧序曲的区别？  结束，体裁，形式不同\n交响诗和交响曲的区别？  标题交响曲通常是三四个或五个乐章组成的一种交响曲，它们在一起描述一个连续的特定的故事或场景，这个故事或场景来自一个音乐以外的故事或事件。\n交响诗是一种单乐章的标题交响乐。用音乐来表现与故事、戏剧、政治事件或个人经历相关的情感和事件。\n什么是无词歌？  是门德尔松用来指那种在伴奏声部的衬托下，旋律进行得像歌唱似的钢琴独奏曲。\n浪漫主义时期的标题交响曲有什么特点？  浪漫主义交响曲在沿袭了古典主义纯音乐交响曲传统方面，重视音乐自身内部潜能的发挥和乐器音色的组合，但也受到浪漫主义情感美学和标题原则的影响 ，在一系列音乐表现手段和乐曲形式方面都处理得比较自由。因此浪漫主义交响音乐的旋律、和声与配器手法方面都有很大发展和变化\n浪漫主义时期的意大利歌剧与德国歌剧的区别？  [[西方音乐史-浪漫主义时期#中期浪漫主义 - 歌剧]]\n意大利威尔第主要采用浪漫主义时期小说创作，乐队不可喧宾夺主，有戏剧结构，拓展歌唱家音域，增加紧张和激情，咏叹调和宣叙调采用乐队伴奏。 德国瓦格纳自创歌剧，有神话色彩，器乐是统治一切的原则，主导动机的手法。\n第四次作业—浪漫晚期的音乐  浪漫主义时期交响诗的创作特点。  交响诗是一种单乐章的标题交响音乐体裁，盛行于19世纪后半叶至20世纪初。它的产生，与19世纪的浪漫主义文艺思潮息息相关，如音乐与文学、绘画等姊妹艺术相互靠拢的倾向，作曲家用器乐曲来表现文学题材的尝试，瓦格纳力图将歌剧发展成为集文学、音乐、戏剧为一体的综合艺术，而同时交响曲则努力拓展表现范围，加强与诗歌、美术和哲学领域的沟通，在形式上，产生了将多乐章交响套曲紧缩为单乐章的愿望，交响诗正是综合上述所有浪漫主义音乐发展倾向应运而生的新体裁。\n浪漫主义时期法国真实主义歌剧的特点。  真实主义歌剧是在法国自然主义文学的影响下，以反对瓦格纳乐剧的反作用形式出现的。 它主要描写日常生活，特别是描写发生在下层阶级现实生活中的一些事情。 真实主义歌剧与文学上的自然主义和真实主义相比，具有许多相同点，例如，它们都将视角转向了社会的底层，都有批判现实主义的笔法.\n以理查德·施特劳斯的歌剧《莎乐美》的创作为例，简述浪漫晚期的音乐风格特点。  “七层纱之舞”。开放，超前\n以德彪西《牧神午后前奏曲》为例，简述印象主义音乐的语言特征。  模糊\n","date":"2021-12-06T15:01:00+08:00","permalink":"http://atksoto.com/%E8%A5%BF%E6%96%B9%E9%9F%B3%E4%B9%90%E5%8F%B2-%E4%BD%9C%E4%B8%9A/","title":"西方音乐史-作业"},{"content":" 数列极限  定义 Stolz 单调有界   函数极限  定义 连续 无穷大 无穷小  等价无穷小 1的无穷次 $e^{\u0026hellip;}$   一致连续  证明 $|f(x_1)-f(x_2)| \u0026lt; A |x_1-x_2|$ $arctanx$与中值定理     导数  隐函数求导 参数方程求导  $\\frac{dy}{dx} = \\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}}$   高阶导数  莱布尼兹公式  $(uv)^n = \\sum_{k=0}^nu^{(n-k)}v^{k}$     微分中值定理  罗尔中值定理 拉格朗日中值定理   函数性质 洛必达   泰勒公式  微分 Taylor公式  Peano余项 Lagrange余项        不定积分  积分表 换元法 分部积分   定积分  变上限积分 n的无穷转定积分   积分几何  体积，表面积 [[数学分析-关于几何的积分]]   广义积分  瑕积分 狄利克雷 阿贝尔   微分方程  ![[常微分方程解法.png]]   [[数学分析-积分部分证明]]   \n","date":"2021-12-04T23:40:00+08:00","permalink":"http://atksoto.com/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%A4%A7%E7%BA%B2/","title":"数学分析大纲"},{"content":"uu们最近给我推的歌\n大家一起分享\n YOASOBI新专辑   椎名林檎       ","date":"2021-12-04T15:49:00+08:00","permalink":"http://atksoto.com/%E6%8E%A8%E6%AD%8C-%E7%AC%AC%E4%BA%8C%E6%9C%9F/","title":"推歌 第二期"},{"content":"《假如爱有天意》\n \n最近又在听《假如爱有天意》，遂又回去二刷原作 一年了，依然感动\n        \n","date":"2021-12-03T22:11:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/y6rPnu.png","permalink":"http://atksoto.com/%E5%81%87%E5%A6%82%E7%88%B1%E6%9C%89%E5%A4%A9%E6%84%8F/","title":"假如爱有天意"},{"content":"uu们最近给我推的歌 大家一起分享\n   カンタレラ~grace edition~ \n这首的交响版本也很棒：\n   ODDTAXI\n  魂之轮回 HB to 剑风\n  魂のルフラン (魂之轮回)\n  イナヅマ侍\n  旅行\n  ","date":"2021-12-01T23:18:00+08:00","permalink":"http://atksoto.com/%E6%8E%A8%E6%AD%8C-%E7%AC%AC%E4%B8%80%E6%9C%9F/","title":"推歌 第一期"},{"content":"《海街日记》\n \n \n \n \n \n","date":"2021-12-01T19:25:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/GkSWWl.png","permalink":"http://atksoto.com/our-little-sister/","title":"Our Little Sister"},{"content":"sudo vim /usr/local/bin/command\n/usr/local/bin/ 下创建的文件默认在path中 必须使用sudo\n#!/bin/bash do something sudo chmod +x /usr/local/bin/command\n即可全局使用 command\n","date":"2021-11-30T21:30:00+08:00","permalink":"http://atksoto.com/macos%E5%85%A8%E5%B1%80%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/","title":"MacOS全局可执行文件"},{"content":"2021年匆匆的过去了，看上面这张图的话，似乎眼前的这些周期都很快将要画上句号。\n \n2021年仍然是不平凡的一年，仍然记得年初开学前的焦虑，现在回首，已是云淡风轻。\n昨天也做了一件有意义的事情，终结了我的某个让我焦虑了一年的项目，很遗憾，和一般情况不同，不是顺利完成了，而是我终于宣告退出了，不知是我诉苦奏效还是项目确实没有什么意义，身边人在最后关头支持我的退出。且不谈这个项目的实际意义，我已经丧失了对项目的兴趣，尽管起初驱动我的也不是兴趣，最主要的还是这一年在这一件事上，循环往复的都是焦虑和难以推进，在近期，也是我今年最忙的时间段，项目突然开始快速推进，我借着这个机会，跟老板提出退出。最终什么都没有拿到，倒是这一年，更像是两年，本就社恐，又无经验，还得不到具体的指导，老板问我有没有给我压力，确实也没有，是自己给自己增加了不少压力，而我，2021年末的我，已经不愿再做自己不喜欢的事情了。让此事告终，心情也好了不少。\n这几天甚是忙碌，周围人都出去玩乐了，我还在做作业，复习重修的课程。小伙伴今天下午约我出去玩，我才意识到这已经是这学期不知道第几次因为要考试而拒绝了。倒也不觉得情绪低，因为清楚自己在做什么，为什么忙，除了时间确实不够用，熬了几次夜，反倒挺有兴致的。也非常期待下一周，校历第13周的结束，这意味着编译和数据库的结课，数分期中考试的结束，物联网，安卓大作业的结束，虽然此时此刻他们都还没有结束，也不知道会以什么样的方式结束。\n写完这篇，Typora提醒我15天后他要开始收费了。回想疫情居家的那一学期，在6系学长为我们讲解数据结构时，看到了学长的Typora，一眼喜欢上了这个软件，专门加了学长好友去问这款软件叫什么，学长告诉我，如果到了6系会经常用到，我还一笑，不曾想过自己会去6系，如今已是在计算机学院的第二年了。恰合主题，时间过得这么快，也算见证了Typora的演变。\n岁末将至，敬颂冬绥\n","date":"2021-11-28T23:59:12+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwvcckpc31j30sg0lcjw0.jpg","permalink":"http://atksoto.com/%E5%B2%81%E6%9C%AB%E5%B0%86%E8%87%B3/","title":"岁末将至"},{"content":"下午突然看到服务器有人发\n \n仔细一看\n \n打开链接一看：\n \n 很无语，一开始以为是国外作案，黑进数据库了，一看我数据库根本没对外网开放\n查来查去发现是有人盗了一个用来处理封禁的账号，进去之后一通乱封\n把数据库恢复了一下备份，玩家还是进不去，我能进去，查了一下litebans的官网，是用了一个封锁服务器进入权限的指令，打了个指令就解决了。\n很低级的手段，很无聊的恶趣味\n 后续 原本晚上前往教学楼复习数分，没有带电脑。\n没想到，在傍晚又被黑了，因为只是还有管理号没有停掉，仅凭手机暂时解决了问题，在仔细推敲后，认为其是通过非法调用我部署在web服务器的litebans端的api来实现用拥有权限的玩家账号去封禁其他玩家。\n结果在稍晚一点又一次被黑，终于意识到，事情根本没有那么复杂，只是因为litebans是BC插件，Authme没办法限制登陆前对指令使用权限，任意一个有litebans权限的账号都在未登陆的情况下可以随意使用指令。其实早就应该发现我留了这种低级漏洞的，也没想道竟然这么久了才有人发现了这个这么简单的漏洞。\n","date":"2021-11-28T16:17:36+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwuxr0uhfdj30yc0jsgn6.jpg","permalink":"http://atksoto.com/ac%E5%8F%88%E8%A2%AB%E9%BB%91%E4%BA%86/","title":"AC又被黑了"},{"content":"IoTMonitor 用于展示IoT课程开发板的相关信息并进行控制\n可以通过调用我们部署的服务器api及时获取开发板的温湿度数据，也可以发送开关电机的指令，并且可以设置温湿度超过某阈值后报警，同时有历史记录来提供任意时间段内好看的温湿度曲线\n \n图片  \n简介 主页面 分为三个部分：设备状态，历史记录，设置\nUI整体使用卡片式扁平设计\n设备状态 刷新按钮和更新温湿度数据，温湿度可以显示此时设备的温湿度传感器信息，打开电机和关闭电机功能用于控制控制板马达\n其中，温湿度会每秒自动进行更新，2位小数点保留\n \n历史记录 通过DatePicker选择起止时间，再点击获取，即可得到此段时间内的温湿度曲线，触摸曲线还可以动态显示任意一点的数值（此处使用了[[SwiftUI 图表库 ChartView]]库）\n默认显示2天前到现在的曲线，第一次打开app时会同步一次\n \n设置 在设置页面，通过选择器选择阈值后点击保存，当温度高于此阈值时，开发板电机将会转动\n同时，打开app后每次阈值的设置会被记录，以便查看设置情况\n \n功能  实时显示开发板传感器温湿度 实时控制开发板电机马达转动与否 获取任意时间段开发板传感器温湿度历史曲线 通过设置过热阈值，当温度超过此值，进行报警 后台实时更新  实现 该app主要通过HTTP GET和POST请求像我们的服务器后端发送请求，后端通过电信平台的api调用来发送相关指令，电信平台再把指令下达到开发板，来实现app与开发板的交互\n该app的UI部分复用项目Memo的代码\n","date":"2021-11-28T02:54:12+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwuaqehi6ej30lg0eggmc.jpg","permalink":"http://atksoto.com/iotmonitor/","title":"IoTMonitor"},{"content":"《现在去见你》\n \n \n哪怕早知道我会早早离开，也不愿辜负有你们的这一生。\n","date":"2021-11-26T19:06:03+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwt3jhmdacj31gm0luq6m.jpg","permalink":"http://atksoto.com/%E6%88%91%E7%88%B1%E6%88%91%E5%BA%A6%E8%BF%87%E7%9A%84%E6%89%80%E6%9C%89%E6%97%B6%E9%97%B4/","title":"我爱我度过的所有时间"},{"content":"新北区迷惑大赏 我真的不理解为什么他们喜欢在这片区域晒太阳和带小孩\n上个学期上早八吃早饭，总会有一群阿姨比我更早，我不知道他们着不着急，反正我很着急\n \n新的乒乓球桌也理所应当的成为了他们的活动设施\n \n合一又是另一回事，属于是中小学食堂了\n \n","date":"2021-11-26T10:22:27+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwsc4q052vj30sg0lcq6v.jpg","permalink":"http://atksoto.com/%E6%96%B0%E5%8C%97%E8%80%81%E5%B9%B4%E6%B4%BB%E5%8A%A8%E4%B8%AD%E5%BF%83/","title":"新北老年活动中心"},{"content":"浪漫主义时期 （1820-1900）\n特点 序幕 舒伯特《魔王》 韦伯\n公众音乐会的变化：古典时期的公众音乐会和社交活动是相似的，随意聊天吃喝打拍子，哼唱鼓掌，1840年 古典音乐会 礼仪形成 曲目确定\n1800以前 音乐几乎是一次性的为某一时刻而创作，贝多芬以后一代人将前辈作品视作经典反复演奏\n乐器音色更加丰富——工业革命的进步。例如长笛（木制-\u0026gt;金属+指动机械装置）圆号（加调音赛）\n交响乐队更加庞大，新乐器加入。例如马勒119 柏辽兹《幻想》89\n产生了专职指挥。1820年，作曲家路易·施波尔成为用木质指挥棒指挥乐队的第一人。浪漫早期，指挥家由一个打拍子的人变成一个乐谱解释者，现代指挥家出现。\n产生了演奏大师。独奏大师的时代，为了迎合观众。意大利帕格尼尼，匈牙利李斯特钢琴之王。 作品宏大复杂。马二，一个半小时。\n音乐内容：\n 爱情 大自然《田园》《山调序曲》 神治 《魔弹射手》《尼伯龙根的指环》 自传性质 《幻想交响曲》  音乐结构自由\n标题音乐和非标题音乐并存\n旋律悠长（多用半音 具不确定性）\n和声 建立半音和声，不和谐和弦\n自由速度 tempo rubato\n力度强烈 极致的强与弱\n调式调性 转调离调变化频繁\n早期浪漫主义 艺术歌曲 主要采用诗人诗作\n钢琴：伴奏烘托\n歌唱：意大利美声\n例：《魔王》——歌德叙事诗\n舒伯特 艺术歌曲（600多首）、交响曲……\n作品比前人更具有抒情性，充满歌唱感\n艺术歌曲《鳟鱼》 交响曲 《第八未完成交响曲》\n罗伯特 舒曼 19世纪德国作曲家、音乐评论家\n《蝴蝶》《狂欢节》《童年情景》\n钢琴《A小调钢琴协奏曲》OP 54\n《桃金娘》（单三部曲式 ABA）献给爱妻克拉拉（著名钢琴家）\n标题音乐 分类：\n 音乐会序曲 标题交响曲 交响诗  音乐会序曲 门德尔松（学院派作曲家，风格多奏鸣曲快板，甜美轻盈）首创\n门德尔松《仲夏夜之梦》序曲（第一部音乐会序曲）\n门德尔松《婚礼进行曲》\n瓦格纳《婚礼进行曲》\n埃克托 柏辽兹 交响曲\n《幻想交响曲》\n李斯特交响诗《前奏曲》\n曲式结构 4/4 自由-奏鸣曲\n呈示部——展开部——再现部——尾声\n钢琴音乐 音域拓宽，音锤改为毛毡布包裹，钢琴装上2个踏板\n舒曼《儿时情景》——《梦幻曲》\n门德尔松——无词歌《春之歌》\n弗朗茨 李斯特 匈牙利 1811-1886\n钢琴之王，作曲家，宗教神父\n改编700多首，改编手法叹为观止 “改编大师”\n三部曲式 钢琴小品《爱之梦》\n肖邦 (1810-1849)\n19世纪浪漫主义时期最优秀的作曲家，钢琴演奏家\n波兰 历经坎坷的国家 1830波兰沦陷时一直在播放肖邦的《革命练习曲》\n钢琴诗人 只创作钢琴音乐\n离开祖国《E大调练习曲（离别曲）》\n1830年后在法国巴黎发展\n《第6号（小狗）圆舞曲》\n音乐的诗情画意  采用不对称结构 朗诵音调 自由速度 Tempo Rubato  遗作 《升C小调夜曲》 具肖邦特色\n音乐中的民族性 玛祖卡舞曲：\n 3/4拍舞曲 重音在第二拍 多用波兰民间音调 曲式：回旋曲式 ABAC  谐谑曲  四首谐谑曲。 其中《降b小调谐谑曲》 最富于诗意 曲式：自由的奏鸣曲式 3/4 拍  中期浪漫主义 - 歌剧 威尔第 《奥菲欧》\n意大利 威尔第 主要采用浪漫主义时期小说创作\n作品：\n 早期 《纳布科》 合唱《飞吧，金色的翅膀》（被称为意大利第二国歌） 中期 《弄臣》 《游吟诗人》 《茶花女》 晚期 《阿依达》 （巅峰之作）  创作特点：\n 分曲体结构 强烈的戏剧冲突 咏叹调和宣叙调采用乐队伴奏 旋律简单易记 拓展歌唱家音域，增加紧张和激情 自由速度 有戏剧结构。场景与卡巴列塔常常出现在歌剧的每一幕结尾 乐队不可喧宾夺主  德国 瓦格纳 文学家，戏剧家，音乐家，哲学家\n自创歌剧 神话色彩\n音乐戏剧 “乐剧”\n独特的德国歌剧\n作品\n 《汤豪瑟》单三部曲式ABABA 四联剧 《尼伯龙根的指环》 史上篇幅最大作品  序夜：《莱茵的黄金》 第一夜 ：《女武神》 第二夜 ：《齐格飞》 第三夜 ：《诸神的黄昏》     创作特点：\n 无终止旋律 器乐是统治一切的原则（乐队淹没人声） 主导动机的手法  浪漫主义晚期-勃拉姆斯的创作 勃拉姆斯 德国作曲家\n“浪漫的古典主义”作曲家\n作品：\n 《摇篮曲》 室内乐《C小调第三钢琴弦乐四重奏》-献给克拉拉 《第二交响曲》  柴可夫斯基 俄国作曲家\n受影响：\n俄国民族 能歌善舞\n俄国社会 沙皇统治时期，农民起义\n三个女人 初恋(法国歌唱家) ，妻子，精神支柱\n作品（涉猎各种题材）：\n  三部芭蕾\n 《天鹅湖》    《睡美人》 《胡桃夹子》    七部交响曲\n 《E小调第五交响曲》-命运动机-贯穿四个乐章      \u0026hellip;  理查德 施特劳斯 《七纱舞》\n马勒 奥地利作曲家\n","date":"2021-11-23T20:34:50+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/CxHj8q.jpg","permalink":"http://atksoto.com/%E8%A5%BF%E6%96%B9%E9%9F%B3%E4%B9%90%E5%8F%B2-%E6%B5%AA%E6%BC%AB%E4%B8%BB%E4%B9%89%E6%97%B6%E6%9C%9F/","title":"西方音乐史-浪漫主义时期"},{"content":" \n想来自己第一次跟着泳社学游泳到现在已经2年了，当初教我的人大多都已经毕业了。\n","date":"2021-11-23T12:36:52+08:00","permalink":"http://atksoto.com/%E6%B3%B3%E7%A4%BE%E7%BA%A6%E6%B8%B8%E7%BE%A4%E7%9A%84%E6%9C%89%E8%B6%A3%E8%A7%81%E9%97%BB/","title":"泳社约游群的有趣见闻"},{"content":"Demo title:\ndate: 2021-11-23 10:09:18\ntags: [hexo]\ncategories:\ncover:\n官方说明1 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。\n   参数 描述 默认值     layout 布局 config.default_layout   title 标题 文章的文件名   date 建立日期 文件建立日期   updated 更新日期 文件更新日期   comments 开启文章的评论功能 true   tags 标签（不适用于分页）    categories 分类（不适用于分页）    permalink 覆盖文章网址    excerpt Page excerpt in plain text. Use this plugin to format the text    disableNunjucks Disable rendering of Nunjucks tag {{ }}/{% %} and tag plugins when enabled    lang Set the language to override auto-detection Inherited from _config.yml   thumbnail 封面       https://hexo.io/docs/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-23T10:09:18+08:00","permalink":"http://atksoto.com/hexo-front-matter/","title":"Hexo-Front-matter"},{"content":"今日看到北京电影学院的行为艺术，甚感封校许久政策就是最明显的校内不同群体的利益冲突，比如在BUAA，冲封校冲得最厉害的，似乎是大四的同学，因为很多人急于出去实习科研。对于一些每天的生活只有卷的同学，封校政策并无大碍。对于北航家属呢，此政策影响不到他们的正常出行。对于我呢，在我想出去玩的时候，对政策感到厌恶，在我不想出玩的时候，却也觉得无所谓。\n《肖申克的救赎》\n \n更新于2021-11-23 10:17\n昨天刚吐槽完这个，今天BUAA就改报备制了，近期也并无心出门\n《不至于》\n \n","date":"2021-11-22T15:28:59+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwnymv1zyrj31780u0ane.jpg","permalink":"http://atksoto.com/%E5%85%B3%E4%BA%8E%E5%B0%81%E6%A0%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E8%89%BA%E6%9C%AF%E5%BE%88%E6%9C%89%E5%86%B2%E5%87%BB%E5%8A%9B/","title":"关于封校的行为艺术——很有冲击力"},{"content":"[[2021美赛正文.pdf]] (链接)\nGitHub开源供参考\n2021年初，我与两位室友组队参与了美国大学数学竞赛（MCM-ICM）\n后来有幸拿到了M奖（Meritorious Winner）\n又一年美赛，有一些朋友询问经验，其实拿到这个奖比起其他投入了很多的同学我们也只是运气比较好罢了，没有太多真正意义上值得参考的经验，在此仅简要谈谈。\n首先，我和室友都没有任何建模基础，起初是一时兴起报名了比赛。二位室友的专业是电子信息工程，我的专业是计算机科学与技术，同属信息类，在大一时学过C语言基础和数据结构。\n在任务的分配上，起初我们是一人负责建模，一人负责写代码，一人负责写论文，后来在实际比赛的过程中，因为最初任务集中在建模和计算，于是二位队友一起建模和绘图，后期二位队友主要一起写文章和作图，我全程负责写代码。\n选题上，在比赛之前官方发布了一份数据集，就已经提前下载下来，开题后对几个题目快速浏览了一下，起初考虑 Problem A: Fungi 和 Problem C: Confirming the Buzz about Hornets，队友主张A，但是因为A题很难快速想出一个合适的模型。我主张C，C题需要使用Machine Learning，和专业算是比较契合，但是我看了一上午ML相关知识并没有学会，只好最终选择了Problem D: The Influence of Music，一个比较简单的偏大数据分析的题目。\n代码上，我无Matlab经验，选择了用Python进行数据处理，现学了诸如numpy，pandas，matplotlib等库的用法并加之分析，说来也好笑，感觉自己在复习数据结构，用了图结构，DFS等算法，还在图遍历陷入死循环的时候发现了官方数据集的一个bug（$理论上有 A\\in B但是A中出现了1条B中不存在的数据$）。\n这里也是我们的一个失误，没有经验，没有想到数据要预处理，后期因为数据的一些问题，我以为是我自己算法的问题，卡了很久。\n还有一个个人认为比较重要的一点，就是无论建模难度如何，完成度一定要高。\n总的来说，实际上我们是没有什么建模经验和准备的情况下参加了比赛，三天时间学了很多东西（我是真的疯狂恶补敲python），每天不分昼夜的连麦也非常非常欢乐，中间也偷偷摸鱼玩了会游戏，最终出结果也很有成就感（尤其是算出Beatles的影响力时），最大的体验就是重在参与吧，真的是一段难忘的体验。\n \n","date":"2021-11-21T11:36:00+08:00","permalink":"http://atksoto.com/%E5%85%B3%E4%BA%8E2021%E7%BE%8E%E8%B5%9B/","title":"关于2021美赛"},{"content":"今赴一场蓄谋已久的生日宴会，开场一个半小时后先行撤退且不辞而别，在此先把责任全部归咎于我自己，母上也对我的行为直呼无趣，倒也不是自讨没趣，只是封校许久难得有机会出来，想要自行去溜达一圈。\n我在乘车前往目的地的路上，看到鸟巢灯火通明的一瞬间，突然感到与繁景告别已久（一个多月），仿佛自己离开了这个城市。恍然间审视起来自己这一个月真的是在有意义的活着吗？貌似是陷在编译里面虚度时间。忽然想起那句：北航人是没有生活的(链接)，直呼赞同。故在按部就班完成生日的惊喜后按耐不住，感觉在座的各位都有自己在这一场聚会中想要做的事情，我不甚相融其中，只想奔赴鸟巢，而且还有点饿，想吃点告别已久的，学校外边的食物，遂离开。\n \n奔赴鸟巢并不顺利，沿湖东路莫名被封，我四处绕路，路上遇见几位也是如此，最后还是从东侧大道进入，赶在闭园的前几分钟，好心的保安提示我赶紧进去，进去后反倒不如在湖边拍下的风景好，中轴线的人也不多，只有几个年轻人还在滑滑板，却也算完成了今日的心愿。\n见到倒计时板只剩下76天，想到第一次来这个地方，已相隔七百来天，不甚感慨，在BUAA的这两年，在北京的这两年。\n \n离开之际，地铁口附近有一些劲爆的音乐和放纵的，各个年龄段的朝阳群众正在狂欢。待了一会儿，离开了，也没吃到饭。（回BUAA吃了难吃的烤冷面和土豆）\n \n","date":"2021-11-19T23:34:01+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwocp0mkarj30sg0lc43v.jpg","permalink":"http://atksoto.com/%E4%B8%8E%E9%B8%9F%E5%B7%A2%E7%9A%84%E5%8C%86%E5%8C%86%E4%B8%80%E9%9D%A2/","title":"与鸟巢的匆匆一面"},{"content":"词法分析 Before Code Requriement: read testfile.txt, parse every char to word and print them. At the same time, memorize type, content and line number of each word.\nFile reading Read by line, scan every char of every string and analyse.\nwhile ((s = bf.readLine()) != null) { ... } Analyse When i get the key word, enter the next analyst.\nwhile ((c = getChar()) != null) { if (c == \u0026#39; \u0026#39; || c == \u0026#39;\\r\u0026#39; || c == \u0026#39;\\t\u0026#39;) { continue; } else if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39; || c == \u0026#39;*\u0026#39; || c == \u0026#39;%\u0026#39;) { words.add(new Word(c)); } else if (c == \u0026#39;/\u0026#39;) { analyseSlash(); } else if (c == \u0026#39;(\u0026#39; || c == \u0026#39;)\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;]\u0026#39; || c == \u0026#39;{\u0026#39; || c == \u0026#39;}\u0026#39;) { words.add(new Word(c)); } else if (c == \u0026#39;\u0026gt;\u0026#39; || c == \u0026#39;\u0026lt;\u0026#39; || c == \u0026#39;=\u0026#39; || c == \u0026#39;!\u0026#39;) { analyseRelation(c); } else if (c == \u0026#39;,\u0026#39; || c == \u0026#39;;\u0026#39;) { words.add(new Word(c)); } else if (c == \u0026#39;\u0026#34;\u0026#39;) { analyseCitation(); } else if (c == \u0026#39;\u0026amp;\u0026#39; || c == \u0026#39;|\u0026#39;) { analyseLogic(c); } else if (Character.isDigit(c)) { analyseDigit(c); } else if (Character.isLetter(c) || c == \u0026#39;_\u0026#39;) { analyseLetter(c); } } Common For example, when I get \u0026lsquo;+\u0026rsquo;, I directly new a Word typify the \u0026ldquo;PLUS\u0026rdquo;.\nFunction For example\nWhen I get \u0026lt; , enter functionanalyseRelation read one char more. If it is=, analyze LEQ\u0026hellip;\nif (c == \u0026#39;\u0026lt;\u0026#39;) { c = getChar(); if (c == \u0026#39;=\u0026#39;) { words.add(new Word(\u0026#34;\u0026lt;=\u0026#34;)); } else { unGetChar(); words.add(new Word(\u0026#34;\u0026lt;\u0026#34;)); } analyseLogic is as the same.\nDigit and Letter Digit: When I get a digit, it means I will scan a serial of some digits and turn them into a Word typify \u0026ldquo;INTCON\u0026rdquo;.\nLetter: When I get a letter, it means I will scan a string about letter or digit. It maybe a \u0026ldquo;IDENFR\u0026rdquo; or \u0026ldquo;STRCON\u0026rdquo;, which depends on whether it is in key map or not.\nWord class Word:\npublic class Word { private String identification; private String content; private String type; } Capsulate the initial function, I only need to new Word(...) in the main processor, which will create the corresponding word.\nFor example\npublic Word(char identification) { this.identification = String.valueOf(identification); this.type = new KeyWordMap().getType(this.identification); this.content = this.identification; } As for KeyWordMap, it is a HashMap, mapping the string of word and its type.\npublic KeyWordMap() { keyWords = new HashMap\u0026lt;\u0026gt;(); keyWords.put(\u0026#34;main\u0026#34;, \u0026#34;MAINTK\u0026#34;); keyWords.put(\u0026#34;const\u0026#34;, \u0026#34;CONSTTK\u0026#34;); keyWords.put(\u0026#34;int\u0026#34;, \u0026#34;INTTK\u0026#34;); ... } After Code File reading Read file by line is not convenient for preread and undo, so I read the file into a single String at first.\nThe method is read by line, add \\n after every line and scan every char. When I get \\n, lineNum++\nprivate String transferFileToCode() { BufferedReader bf = new BufferedReader(reader); StringBuffer buffer = new StringBuffer(); String s = null; while ((s = bf.readLine()) != null) { buffer.append(s).append(\u0026#34;\\n\u0026#34;); } return buffer.toString(); } Analyse About analyst, it is different from what before coding.\nFirst, I need analyze word one by one, so I add global variety index to memorize where is the pointer.\nBesides, I met the situation that I need read one more or undo, so I encapsulate the function ungetChar and getChar, which will be convenient for me to analyze.\nprivate Character getChar() { if (index \u0026lt; code.length()) { char c = code.charAt(index); if (c == \u0026#39;\\n\u0026#39;) { lineNum++; } index++; return c; } else { return null; } } private void unGetChar() { index--; char c = code.charAt(index); if (c == \u0026#39;\\n\u0026#39;) { lineNum--; } } Slash  // : When it comes to \\n , stop.  do { c = getChar(); if (c == null || c == \u0026#39;\\n\u0026#39;) { return; // 判断为//注释，结束分析  } } while (true); /* */: Get char until */ appears  do { c = getChar(); if (c == null) { return; } if (c == \u0026#39;*\u0026#39;) { c = getChar(); if (c == \u0026#39;/\u0026#39;) { return; // 判断为/* */注释，直接结束分析  } else { unGetChar(); } } } while (true); 语法分析 Requirement: Based on the words identified by the lexical analysis program, identify various grammatical elements according to the grammatical rules. Recursive descent method is used to analyze the grammatical components defined in the grammar.\nBefore Code Data Reading Like the lexical analyst, I prepared function getWord getNextWord and so on. At the same time, there is a global variety (Word) curWord to display which word it is when I read ArrayList\u0026lt;Word\u0026gt; words  from lexical analyst one by one.\nMy analyst tragedy is as follows:\nTo normal rule: I keep getting words and analyze them\nTo expression rule: I scan the whole expression first, which is implemented by function getExp. Then I divide the expression and use method recursive descent to analyze them.\ngetExp like\nprivate ArrayList\u0026lt;Word\u0026gt; getExp() { ArrayList\u0026lt;Word\u0026gt; exp = new ArrayList\u0026lt;\u0026gt;(); while (true) { if (word is symbol of end) { break; } ... getWordWithoutAddToGrammar(); exp.add(curWord); word = getNextWord(); } return exp; } recursive descent According to Grammatical Rules, code function for every term of rule.\nMain idea: read a word, check what it symbolize and enter the next analyzing function.\nFor example:\nto\nCompUnit → {Decl} {FuncDef} MainFuncDef // 1.是否存在Decl 2.是否存在 FuncDef I analyze like this:\nprivate void analyseCompUnit() { Word word = getNextWord(); while (word.typeEquals(\u0026#34;CONSTTK\u0026#34;) || ( word.typeEquals(\u0026#34;INTTK\u0026#34;) \u0026amp;\u0026amp; getNext2Word().typeEquals(\u0026#34;IDENFR\u0026#34;) \u0026amp;\u0026amp; !getNext3Word().typeEquals(\u0026#34;LPARENT\u0026#34;))) { analyseDecl(); word = getNextWord(); } while (word.typeEquals(\u0026#34;VOIDTK\u0026#34;) || ( (word.typeEquals(\u0026#34;INTTK\u0026#34;) \u0026amp;\u0026amp; !getNext2Word().typeEquals(\u0026#34;MAINTK\u0026#34;)))) { analyseFuncDef(); word = getNextWord(); } if (word.typeEquals(\u0026#34;INTTK\u0026#34;) \u0026amp;\u0026amp; getNext2Word().typeEquals(\u0026#34;MAINTK\u0026#34;)) { analyseMainFuncDef(); } else { error(); } grammar.add(\u0026#34;\u0026lt;CompUnit\u0026gt;\u0026#34;); } grammar is used for memorize output of lexical analyst and grammar analyst list.\nleft recursion 加减表达式 AddExp → MulExp | AddExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 Check if the exp has \u0026lsquo;+\u0026rsquo; or \u0026lsquo;-\u0026rsquo;. If it has, separate the exp to AddExp and MulExp. Then analyze them separately.\nAfter Code left recursion The method used before is not perfect for recursive descent. So I changed my rewrite way.\nto\n加减表达式 AddExp → MulExp | AddExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 Rewrite it like\nAddExp → MulExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp ... Code like\nprivate void analyseMulExp(ArrayList\u0026lt;Word\u0026gt; exp) { Exps exps = divideExp(exp, new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;MULT\u0026#34;, \u0026#34;DIV\u0026#34;, \u0026#34;MOD\u0026#34;))); int j = 0; for (ArrayList\u0026lt;Word\u0026gt; exp1 : exps.getWords()) { analyseUnaryExp(exp1); grammar.add(\u0026#34;\u0026lt;MulExp\u0026gt;\u0026#34;); if (j \u0026lt; exps.getSymbols().size()) { grammar.add(exps.getSymbols().get(j++).toString()); } } } Function divideExp is used for divide the whole exp passed by getExp or the pre function.\ndivideExp:\nIn: orignal: exp stop symbol: symbol\nOut: List of divided exp and symbol.\nprivate Exps divideExp(ArrayList\u0026lt;Word\u0026gt; exp, ArrayList\u0026lt;String\u0026gt; symbol) { ArrayList\u0026lt;ArrayList\u0026lt;Word\u0026gt;\u0026gt; exps = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Word\u0026gt; exp1 = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Word\u0026gt; symbols = new ArrayList\u0026lt;\u0026gt;(); boolean unaryFlag = false; int flag1 = 0; int flag2 = 0; for (int i = 0; i \u0026lt; exp.size(); i++) { Word word = exp.get(i); if (word.typeEquals(\u0026#34;LPARENT\u0026#34;)) { flag1++; } if (word.typeEquals(\u0026#34;RPARENT\u0026#34;)) { flag1--; } if (word.typeEquals(\u0026#34;LBRACK\u0026#34;)) { flag2++; } if (word.typeEquals(\u0026#34;RBRACK\u0026#34;)) { flag2--; } if (symbol.contains(word.getType()) \u0026amp;\u0026amp; flag1 == 0 \u0026amp;\u0026amp; flag2 == 0) { //UnaryOp  if (word.typeOfUnary()) { if (!unaryFlag) { exp1.add(word); continue; } } exps.add(exp1); symbols.add(word); exp1 = new ArrayList\u0026lt;\u0026gt;(); } else { exp1.add(word); } unaryFlag = word.typeEquals(\u0026#34;IDENFR\u0026#34;) || word.typeEquals(\u0026#34;RPARENT\u0026#34;) || word.typeEquals(\u0026#34;INTCON\u0026#34;) || word.typeEquals(\u0026#34;RBRACK\u0026#34;); } exps.add(exp1); return new Exps(exps, symbols); } Exps\npublic class Exps { private ArrayList\u0026lt;ArrayList\u0026lt;Word\u0026gt;\u0026gt; words; private ArrayList\u0026lt;Word\u0026gt; symbols; } other bugs Most bugs are produced by function getExp and divideExp because of some situations are ignored. So I always get something like index out of range\u0026hellip;\nSo I changed some symbol of stop getting expression and modify the rules to divide or not the expression and so on.\n错误处理 Official errors defination\n \nBefore Code Create the symbol table Symbol class\npublic class Symbol { private String type; private int intType; private String content; private int area = 0; } Type means the type of the symbol.\nIntType is an integer. If it\u0026rsquo;s 0, the symbol is int. if it\u0026rsquo;s 1, the symbol is int[], if it\u0026rsquo;s 2, the symbol is int[] []\u0026hellip;\nContent is its content.\nArea is where is it.\nI create a HashMap of Symbols, memorizing symbols created in each area.\nWhen I enter a new area, area++. When I leave an area, area\u0026ndash;, with the corresponding Symbols are destroyed.\nprivate HashMap\u0026lt;Integer, Symbols\u0026gt; symbols = new HashMap\u0026lt;\u0026gt;(); private HashMap\u0026lt;String, Function\u0026gt; functions = new HashMap\u0026lt;\u0026gt;(); private ArrayList\u0026lt;Error\u0026gt; errors = new ArrayList\u0026lt;\u0026gt;(); private int area = -1; private boolean needReturn = false; private int whileFlag = 0; needReturn means if the current function need to return.\nwhileFlag  means if the current code block is in while circle.\nErrors a Just check format\npublic boolean isFormatIllegal() { for (int i = 1; i \u0026lt; content.length() - 1; i++) { char c = content.charAt(i); if (!isLegal(c)) { if (c == \u0026#39;%\u0026#39; \u0026amp;\u0026amp; content.charAt(i + 1) == \u0026#39;d\u0026#39;) { continue; } return true; } else { if (c == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; content.charAt(i + 1) != \u0026#39;n\u0026#39;) { return true; } } } return false; } private boolean isLegal(char c) { return c == 32 || c == 33 || (c \u0026gt;= 40 \u0026amp;\u0026amp; c \u0026lt;= 126); //offical defination } b c B: Every time I get an identity, check if there is the same symbol has been defined in this area.\nprivate boolean hasSymbolInThisArea(Word word) { return symbols.get(area).hasSymbol(word); } C: Check all area. If the symbol has been defined. Functions are as the same.\nprivate boolean hasSymbol(Word word) { for (Symbols s : symbols.values()) { if (s.hasSymbol(word)) { return true; } } return false; } d e To check if the function parameters are matched, I memorize parameters of every function and when I met a function call, I will scan the function call parameters and match them. I prepare a function to do this. Finally I found I need to use recursive descent again, so I add the check procedure to the recursive descent of the grammatical analyst. Please check the After Code/Error d and e\nf g There is a global variety needReturn used to display if the current function need return. if it does but there is no return in the end of the code block, or if it doesn\u0026rsquo;t but there is return, the error will be memorized.\nh Just check if it is a const.\nif (isConst(word)) { error(\u0026#34;h\u0026#34;, word.getLineNum()); } i j k Capsulate function about checking missing of the symbol\nFor example:\nprivate void checkParent() { if (getNextWord().typeEquals(\u0026#34;RPARENT\u0026#34;)) { getWord();// )  } else { error(\u0026#34;j\u0026#34;); } } l Count the number of the parameters of string and printf separately and check if they equal.\nm There is a global variety whileFlag symbolize if the code block is in while circle. If it isn\u0026rsquo;t, any continue and break will produce error.\nAfter Code Area I mark the area++ when I get a block or a function, but it will lead to the situation that when enter a code block of a function, the parameters of the function can\u0026rsquo;t be memorize in the different are with the block of the function. So I changed the rules to mark area++.\nprivate boolean analyseBlock(boolean fromFunc) { ... if (!fromFunc) { addArea(); } ... } Only when the block is not from the function, the area++.\nError d and e To check if the function parameters are matched, I set an array for every function.\npublic class Function { private String type; private String content; private String returnType; private ArrayList\u0026lt;Integer\u0026gt; paras; } When I get a function, I memorize its return type and paras.\nAs for the ArrayList\u0026lt;Integer\u0026gt; paras, it reflects as follows:\n   Type Example Integer     Void  -1   Int a 0   Int[] a[] 1   Int[] [] a[] [3] 2    So when I get a function call, I will check the parameter of it with what I have memorized before.\nprivate void checkParasMatchRParas(Word ident, ArrayList\u0026lt;Integer\u0026gt; paras, ArrayList\u0026lt;Integer\u0026gt; rparas) { if (paras.size() != rparas.size()) { error(\u0026#34;d\u0026#34;, ident.getLineNum()); } else { for (int i = 0; i \u0026lt; paras.size(); i++) { if (!paras.get(i).equals(rparas.get(i))) { error(\u0026#34;e\u0026#34;, ident.getLineNum()); } } } } As for getting the parameters real type, I add the analyst procedure to the recursive descent of the grammatical analyst. Just like:\nprivate int analyseExp(ArrayList\u0026lt;Word\u0026gt; exp) { int intType = analyseAddExp(exp); grammar.add(\u0026#34;\u0026lt;Exp\u0026gt;\u0026#34;); return intType; } Every recursion will return an intType, which symbolize the final type of the expression.\nBecause the terms of one expression must be the same type, so I return only one of them.\nThis is the exit of the recursion. It will return a correct type of the expression to the top of the function.\nprivate int analyseLVal(ArrayList\u0026lt;Word\u0026gt; exp) { int intType = 0; ... if (word.typeEquals(\u0026#34;LBRACK\u0026#34;)) { intType++; ... } ... if (hasSymbol(ident)) { return getSymbol(ident).getIntType() - intType; } else { return 0; } } 代码生成 In this part, I chose to generate Pcode.\nI designed a type of Pcode which is an Inverse Bolan expression stack and symbol table based virtual code.\nAt the same time, I designed virtual machine to execute them.\nThe Pcode virtual machine is an imaginary machine used to run Pcode commands. It consists of: A code area (code), an instruction pointer (EIP), a stack, a var_table, a func_table and a label_table.\nIn the following passage, I will introduce how Pcode executes first and how to produce Pcode next.\nBefore Code How does the virtual machine run First, we need a codes list and a stack(int).\nAn eip: presents the address of current running code.\nA varTable: memorizes the address of the variety in stack.\nA funcTable: memorizes the address of the function in codes list.\nA labelTable: Memorizes the address of the label in codes list.\nThen, run the code one after another and manage the stack.\nHow to distinguish different variety Before generate codes, differentiate varieties from different scopes by its only scope number, like: areaID + \u0026quot;_\u0026quot; + curWord.getContent(). In this situation, the variety will not appear more than once in codes, except for recursive function call, which will be solved by push varTable to stack(show later).\nSpecific Code Definition First, define a class for PCode:\npublic class PCode { private CodeType type; private Object value1 = null; private Object value2 = null; } It presents one code object, which has a CodeType and two operating values. CodeType is an enum. Value1 and value2 maybe Integer or String or null, which depends on specific code type.\nCalculation Type Two operators:\nint b = pop(); int a = pop(); push(cal(a,b)); Single operator:\npush(cal(pop())); VAR VAR command to declare a variable, save the variable name and the address assigned to it in the variable table.\ncase VAR: { Var var = new Var(stack.size()); varTable.put((String) code.getValue1(), var); } Var.class:\npublic class Var { private int index; private int dimension = 0; private int dim1; private int dim2; } DIMVAR DIMVAR command to declare an array. Set the dimension information of the var.\ncase DIMVAR: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); var.setDimension(n); if (n == 1) { int i = pop(); var.setDim1(i); } if (n == 2) { int j = pop(), i = pop(); var.setDim1(i); var.setDim2(j); } } PLACEHOLDER PLACEHOLDER command to grow the stack down, allocate the new space to the variety and array.\ncase PLACEHOLDER: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); if (n == 0) { push(0); } if (n == 1) { for (int i = 0; i \u0026lt; var.getDim1(); i++) { push(0); } } if (n == 2) { for (int i = 0; i \u0026lt; var.getDim1() * var.getDim2(); i++) { push(0); } } } Other Calculation type: pop the stack top once or twice, calculate them and push again.\nJump Type: When it\u0026rsquo;s command about jump, just check if the condition is satisfied and change the eip.\nFunction call: as follows\nFunction call procedure First, before function call, there will be some parameters to be pushed into the stack. Each will be followed by a RPARA command, which memorize the address of the previous variety.\ncase RPARA: { int n = (int) code.getValue1(); if (n == 0) { rparas.add(stack.size() - 1); } else { rparas.add(stack.get(stack.size() - 1)); } } Second, function CALL.\nMemorize the eip, stack top address, and information about the function(In fact, they will be pushed into stack too). Then update the varTable and eip. Ready for execute function.\ncase CALL: { Func func = funcTable.get((String) code.getValue1()); retInfos.add(new RetInfo(eip, varTable, stack.size() - 1, func.getArgs(), func.getArgs(), nowArgsNum)); eip = func.getIndex(); varTable = new HashMap\u0026lt;\u0026gt;(); callArgsNum = func.getArgs(); nowArgsNum = 0; } Finally, return when it\u0026rsquo;s RET\nRestore eip, varTable from RetInfo, clear the new information pushed when function in the stack.\ncase RET: { int n = (int) code.getValue1(); RetInfo info = retInfos.remove(retInfos.size() - 1); eip = info.getEip(); varTable = info.getVarTable(); callArgsNum = info.getCallArgsNum(); nowArgsNum = info.getNowArgsNum(); if (n == 1) { stack.subList(info.getStackPtr() + 1 - info.getParaNum(), stack.size() - 1).clear(); } else { stack.subList(info.getStackPtr() + 1 - info.getParaNum(), stack.size()).clear(); } } Value or Address Push value or address of the variety is an important thing, it depends on what I need, which will be presented when I describe how to generate codes.\nThe command action is as follows(getAddress is used for get the address of the previous variety ).\ncase VALUE: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); int address = getAddress(var, n); push(stack.get(address)); } ... case ADDRESS: { Var var = getVar((String) code.getValue1()); int n = (int) code.getValue2(); int address = getAddress(var, n); push(address); } Code Generate Code generated from the grammatical analyst procedure.\nDeclaration There is no need to distinguish const and var. When declare a variety, just new a variety and let it point to the stack top. Then if it has an initialization, just push the values one after another. If not, add a PLACEHOLDER command to push something(I push 0) to the stack to hold the place.\nAssign sentence In this situation, first calculate and push the address of the variety to the stack top. Then analyze expressions. After that, there are only two number in the stack, which are address and value. Assign the value to the address.\nCondition control sentence First, generate labels. Then, place jump sentences in the proper places.\nlabels about if and while will be generated and then stored in a stack type structure. like:\nwhileLabels.add(new HashMap\u0026lt;\u0026gt;()); whileLabels.get(whileLabels.size() - 1).put(\u0026#34;while\u0026#34;, labelGenerator.getLabel(\u0026#34;while\u0026#34;)); whileLabels.get(whileLabels.size() - 1).put(\u0026#34;while_end\u0026#34;, labelGenerator.getLabel(\u0026#34;while_end\u0026#34;)); whileLabels.get(whileLabels.size() - 1).put(\u0026#34;while_block\u0026#34;, labelGenerator.getLabel(\u0026#34;while_block\u0026#34;)); Take if as example:\nif (word.typeEquals(\u0026#34;IFTK\u0026#34;)) { codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;if\u0026#34;))); ... analyseCond(\u0026#34;IFTK\u0026#34;); ... codes.add(new PCode(CodeType.JZ, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;else\u0026#34;))); codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;if_block\u0026#34;))); analyseStmt(); codes.add(new PCode(CodeType.JMP, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;if_end\u0026#34;))); codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;else\u0026#34;))); if (word.typeEquals(\u0026#34;ELSETK\u0026#34;)) { getWord(); //else  analyseStmt(); } codes.add(new PCode(CodeType.LABEL, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;if_end\u0026#34;))); } while:\nif (word.typeEquals(\u0026#34;WHILETK\u0026#34;)) { ... codes.add(new PCode(CodeType.LABEL, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while\u0026#34;))); ... analyseCond(\u0026#34;WHILETK\u0026#34;); ... codes.add(new PCode(CodeType.JZ, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while_end\u0026#34;))); codes.add(new PCode(CodeType.LABEL, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while_block\u0026#34;))); analyseStmt(); ... codes.add(new PCode(CodeType.JMP, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while\u0026#34;))); codes.add(new PCode(CodeType.LABEL, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while_end\u0026#34;))); whileLabels.remove(whileLabels.size() - 1); } // break if (word.typeEquals(\u0026#34;BREAKTK\u0026#34;)) { getWord();//break  codes.add(new PCode(CodeType.JMP, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while_end\u0026#34;))); ... } // continue if (word.typeEquals(\u0026#34;CONTINUETK\u0026#34;)) { getWord();//continue  codes.add(new PCode(CodeType.JMP, whileLabels.get(whileLabels.size() - 1).get(\u0026#34;while\u0026#34;))); ... } After Code Because of some runtime errors and information shortages, I added and removed some Pcode. At the same, there are some new troubles about address pass and short circuit calculation.\nSpecific Code Definition In Operation, push() means put value into the top of the stack. pop() means pop the value from the top of the stack.\nCommon Type    CodeType Value1 Value2 Operation     LABEL Label_name Set a label    VAR Ident_name Declare a variety    PUSH Ident_name/Digit push(value1)    POP Address Ident_name *value1 = value2   JZ Label_name  Jump if stack top is zero   JNZ Label_name  Jump if stack top is not zero   JMP Label_name  Jump unconditionally   MAIN   Main function label   FUNC   Function label   ENDFUNC   End of function label   PARA Ident_name Type Parameters   RET Return value or not  Function return   CALL Function name  Function call   RPARA Type  Get parameters ready for function call   GETINT   Get a integer and put it into stack top   PRINT String Para num Pop values and print.   DIMVAR Ident_name Type Set dimension info for array variety   VALUE Ident_name Type Get the variety value   ADDRESS Ident_name Type Get the variety address   PLACEHOLDER   Push something to hold places   EXIT   Exit       CodeType Value1 Value2 Operation     ADD   +   SUB   -   MUL   *   DIV   /   MOD   %   CMPEQ   ==   CMPNE   !=   CMPGT   \u0026gt;   CMPLT   \u0026lt;   CMPGE   \u0026gt;=   CMPLE   \u0026lt;=   AND   \u0026amp;\u0026amp;   OR   ||   NOT   !   NEG   -   POS   +    short circuit calculation There are two situations I need to use short circuit calculation :\n1. if(a\u0026amp;\u0026amp;b) // a is false 2. if(a||b) // b is true This seems not an easy thing and I acutally spent lots of time to solve it.\nMy method is as follows:\nFirst, when I analyze analyseLOrExp, every analyseLAndExp will be followed by a JNZ, which is used for detect if the cond is false. If it is, jump to the if body label. At the same time, I generated cond label, which is ready for the analyseLAndExp.\nprivate void analyseLOrExp(ArrayList\u0026lt;Word\u0026gt; exp, String from) { ... for (...) { ... String label = labelGenerator.getLabel(\u0026#34;cond_\u0026#34; + i); analyseLAndExp(exp1, from, label); codes.add(new PCode(CodeType.LABEL, label)); if (...) { codes.add(new PCode(CodeType.OR)); } if (...) { if (...) { codes.add(new PCode(CodeType.JNZ, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;if_block\u0026#34;))); } ... } ... } } In the analyseLAndExp, every analyseEqExp will be followed by a JZ, which is used for detect if the cond is true. If it is, jump to the cond label I set just now.\nprivate void analyseLAndExp(ArrayList\u0026lt;Word\u0026gt; exp, String from, String label) { ... for (...) { ... analyseEqExp(exp1); if (...) { codes.add(new PCode(CodeType.AND)); } if (...) { if (...) { codes.add(new PCode(CodeType.JZ, label)); } ... } } } By these means, short circuit calculation is solved.\n总结感想 ![[编译实验总结感想]]\n参考资料 https://www.bookstack.cn/read/pandolia-tinyc/about.md\n","date":"2021-11-16T16:29:00+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwuyxmimj1j30tg0c0wfl.jpg","permalink":"http://atksoto.com/alxa_compiler-%E7%BC%96%E8%AF%91%E5%99%A8/","title":"Alxa_Compiler 编译器"},{"content":" 真的很冷\n今天大家的关注点都在S赛，我也未能免俗参与其中\n","date":"2021-11-07T02:04:08+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwkz3r6pstj30sg0lc43b.jpg","permalink":"http://atksoto.com/2021%E5%B9%B411%E6%9C%88%E7%9A%84%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/","title":"2021年11月的第一场雪"},{"content":"Memo Memo用于随时记录，记录生活中的某一刻，记录今天的心情，或是记录看过的一部电影，一本书，留下自己此时的感想，并在自己最爱的电影或书籍的二刷三刷后再次记录下时间和新的想法\u0026hellip;\n灵感来源于豆瓣，比起豆瓣的功能多出的个人需求为：需要一个简洁没有过量冗余信息的片单和书单记录软件，记录二刷，三刷的时间，以及想要随时记录每一天，并且在几年后回顾那年今日，留一些感动与感慨，让每一天都值得被纪念，故开发此软件。\n图片  \n（介绍及短评摘自豆瓣，侵删）\n iPad适配 \nMac, iPad适配\n简介 主页面 主界面分为3个标签：主页，电影，书籍\n主页  观 \n 记 \n电影 这里是你看过的电影片单，你可以随时看到你标记过的所有电影，以及在任何时候添加一个新的电影进入你的片单\n进入某条电影，如果你输入的电影在数据库之中（数据来自豆瓣，侵删），你就可以看到关于电影的介绍：演员，导演，豆瓣评分，类别，介绍等，以及最重要的，在最下方，看到你第一次观看的时间以及感想\n当然，点击此方框，你可以进入到第二次标记的页面，记录下你的第二次观影以及新的感想\n 电影列表 \n书籍 类似电影，这里是你的书单，你可以添加你看过的书籍，并且记录第n次阅读的体验，相信每一次阅读，都会发现不少新东西\n 书 \n功能  标记某一天的感受 标记某本电影，某本书 多次标记某电影和书的观看时间和感受 自动展示电影和书籍的相关图片与简介 图文并茂的主页卡片展示设计 在主页展示进一个月看过的电影 在主页展示今天以及那年今日的感想  架构以及实现 源代码文件共25个\n主要分为三个部分：Controller Model Views\n 源文件树 \nController 一些静态函数，实现点击界面按钮后的某些后端反应以及后端用到的函数，如图像获取，日期格式化，Mark筛选等\n其中图片的读取使用了异步加载url的方式，如果url没有解析成功将不会显示图片\nclass ImageLoader: ObservableObject { var didChange = PassthroughSubject\u0026lt;Data, Never\u0026gt;() var data = Data() { didSet { didChange.send(data) } } init(urlString: String) { guard let url = URL(string: urlString) else { return } let task = URLSession.shared.dataTask(with: url) { (data, response, error) in guard let data = data else { return } DispatchQueue.main.async { self.data = data } } task.resume() } } Model 主要用到的对象为Mark：\nclass Mark: Codable, Identifiable{ var index:Int = 0 var type:ModelType = ModelType.NONE var name = \u0026#34;\u0026#34; var dates: [Date] = [] var feeling = \u0026#34;\u0026#34; init(index: Int,type:ModelType, name:String, date:Date, feeling:String){ self.index = index self.type = type self.name = name self.dates.append(date) self.feeling = feeling } } Movie, Book 为电影和书籍的简介，不进行重复的展示\n他们遵循MarkableObject协议，用于在展示Mark详情时读取object后再作类型判断\nstruct Movie: Hashable, Codable, Identifiable, MarkableObject { var id: String = \u0026#34;\u0026#34; ... } ModelData负责数据存储的任务\n用到了自带的UserDefaults.standard存储数据\nmovies和books分别为电影和书籍数据集，内置在app中\nfinal class ModelData: ObservableObject { var moviesDict = getMoviesDict(movies: load(\u0026#34;movies.json\u0026#34;)) var booksDict = getBooksDict(books: load(\u0026#34;books.json\u0026#34;)) @Published var marks: [Mark] = [] init() { loadMarks() } func loadMarks() { marks = UserDefaults.standard.object(([Mark]).self, with: \u0026#34;Marks\u0026#34;) ?? [] } func saveMarks() { let standard = UserDefaults.standard standard.set(object: marks, forKey: \u0026#34;Marks\u0026#34;) } } ModelType为枚举类型，用于Mark类型判断\nenum ModelType: String, Codable { case NONE = \u0026#34;无\u0026#34; case MOVIE = \u0026#34;电影\u0026#34; case BOOK = \u0026#34;书籍\u0026#34; case DAY = \u0026#34;今天\u0026#34; } Views 界面UI\n用到了environmentObject来同步各个界面的数据\n父界面给子界面传递@Binding的变量，子界面拿到引用直接演示和修改，不会出现数据不同步的问题\n@main struct MemoApp: App { @StateObject private var modelData = ModelData() var body: some Scene { WindowGroup { ContentView() .environmentObject(modelData) } } } MainMenu MarkList: Mark列表，即展示电影和书籍列表\n使用NavigationLink，向子界面：MarkDetail传递mark的引用\n \nHomeView: 主界面\nMark 关于Mark的界面\nMarkDetail: 一个Mark的详情\n大部分子界面都如此UI一样，引入modelData的环境变量，承接上一级传下来的@Binding变量，实现数据的同步\n@EnvironmentObject var modelData: ModelData @Binding var mark: Mark 其中要进行object的解析，如果用户输入能索引本地数据集的一个条目上，将会展示此object的详情\n \nMarkAdd: Mark增加界面\nMarkEdit: Mark修改界面\nMarkToday: 标记今天界面\n这三个UI都用到了@State来实时同步Form表单中的信息\n以至于用户输入能够及时的反应在变量上并且写入modelData\n \nKit 其他组件\n 其他组件 \n电影和书籍详情，时间线，圆形和方形图片，卡片组件等\n均已展示在各个页面中\n","date":"2021-10-28T17:29:00+08:00","image":"https://tva1.sinaimg.cn/large/008i3skNly1gwv08ty64aj31340m4761.jpg","permalink":"http://atksoto.com/memo%E6%96%87%E6%A1%A3/","title":"Memo文档"},{"content":"维也纳古典时期 古典三杰：海顿，莫扎特，贝多芬\n海顿：清唱剧《创世纪》《四季》\n莫扎特：四部喜歌剧 《费加罗的婚礼》 《唐璜》《女人心》 《魔笛》\n贝多芬：奏鸣曲：c小调悲怆奏鸣曲)》、 《F小调热情奏鸣曲》\n交响曲：《第五（命运） 交响曲》、《第九（合唱）交响曲》\n小步舞曲 3拍\n清唱剧 哈利路亚\n维也纳古典主义时期产生了奏鸣曲快板形式\n[[西方音乐史-巴洛克时期]] 开始在乐谱标记强弱\n维也纳古典主义时期渐强渐弱开始大量出现\n贝多芬随想回旋曲《为丢失铜板而愤怒》\n弗朗兹.约瑟夫.海顿 （奥地利作曲家）交响乐之父，弦乐四重奏之父\n套曲形式：乐章：协奏3 奏鸣4 弦乐四重奏4 交响曲4\n意大利喜歌剧\n特点：\n 序曲：奏明式快板 急口令——喜歌剧独有 引入多部声乐重唱 羽管键琴为宣叙调伴奏  莫扎特: “近代钢琴协奏曲之父”\n协奏曲\nconcerto “轮流说话”\n套曲 共三个乐章\n双呈示部的形式\n乐队呈示部（只有乐队）\n独奏呈示部（独奏与乐队）\n展开部\n三者合一 作曲家 指挥 演奏者\n第一乐章 奏鸣曲式快板——双呈示部\n华彩乐段\n贝多芬 1770-1827 德国 57岁 乐圣\n8岁登台\n作为管风琴助理写下最初的音乐作品\n主要作品：\n 6首弦乐四重奏 21首钢琴奏鸣曲  第一阶段 一、二交响曲 三首协奏曲\n32首钢琴奏鸣曲——钢琴 “新约全书”\n第二阶段 热情时期（1803-1817）\n 交响三-八 歌剧 《菲德里奥》 弦乐四重奏《拉祖莫夫斯基的弦乐四重奏》 三重协奏曲 钢琴协奏曲  创新：\n 结构——交响思维 宏大的结构 多变的主题 丰富的展开 主题对称，发展，变化，层出不穷  尾声：相当于第二个展开部\n体裁结构：贝六五个乐章 音乐标题\n华彩：不能创作发挥\n技法：主导动机手法\n第三阶段 升华时期（1817-1827）\n内容更加深刻，形势更加自由奔放\n集古典之大成，开浪漫之先河\n主要作品 庄严的弥撒 五首钢琴奏鸣曲 贝九\n贝九：\n 四乐章：合唱加入到交响中 自由曲式：回旋和变奏的原则 音乐内容：通过人声和歌词表达贝多芬的理想 音乐美学观念：理智与情感的结合     古典 浪漫     理性 感性   严谨、逻辑化、比例均衡 抒情、自由奔放   木刻 油画    ","date":"2021-10-19T17:32:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/5DRCtL.jpeg","permalink":"http://atksoto.com/%E8%A5%BF%E6%96%B9%E9%9F%B3%E4%B9%90%E5%8F%B2-%E7%BB%B4%E4%B9%9F%E7%BA%B3%E5%8F%A4%E5%85%B8%E6%97%B6%E6%9C%9F/","title":"西方音乐史-维也纳古典时期"},{"content":"巴洛克时期 特点 悠长而富于装饰的旋律线条\n大量华丽的装饰音（波光粼粼的装饰音）\n速度不变\n在一个调性上表达情感\n节拍规律\n作品 巴赫 哥德堡变奏曲\n维瓦尔第 四季\n威尔第歌剧 哥林赛达 咏叹调风雨飘摇 花腔 装饰\n调式 和声 调式：大调，小调\n和声：附调，主调\n大调12345671 和声135,246,357\u0026hellip;三度叠制\n小调671234#56\n（1600-1750）巴洛克时期和声：通奏低音-数字低音\n和声特点：主调音乐｜复调音乐\n第一部成熟的歌剧1607年蒙特威尔第《奥菲欧》\n巴赫，亨德尔把复调音乐推向顶峰\n复调音乐听线条 主调音乐听纵向和声\n1650 - 1750 阉人歌手霸占意大利歌剧舞台\n亨德尔歌剧《里纳尔多》咏叹调 让我痛哭吧\n","date":"2021-09-29T08:34:00+08:00","image":"https://pic.mcatk.com/soto-pictures/2021-12/LPGlHr.png","permalink":"http://atksoto.com/%E8%A5%BF%E6%96%B9%E9%9F%B3%E4%B9%90%E5%8F%B2-%E5%B7%B4%E6%B4%9B%E5%85%8B%E6%97%B6%E6%9C%9F/","title":"西方音乐史-巴洛克时期"},{"content":"共晓时期： [[西方音乐史-巴洛克时期]]\n[[西方音乐史-维也纳古典时期]]\n[[西方音乐史-浪漫主义时期]]\n音乐形式 协奏曲，交响曲，奏鸣曲，组曲，练习曲，交响诗，歌剧等\n音乐风格的判断 文化判断音乐风格 帕格尼尼主题变奏曲 愤怒的日子\n下葬，死亡的来临，悲剧的结局\n节拍 波尔卡：2拍，快速，末尾重音\n调式 c小调风景玛祖卡op17.2\n曲式结构 回旋曲式：准确的音乐反复\n浪漫主义时期 歌剧 三大作曲家\n威尔第 阿依达\n芭蕾舞剧，柴可夫斯基\n​\t天鹅湖\n​\t睡美人\n​\t胡桃夹子\n钢琴诗人：肖邦（波兰）不对称的美，朗诵调，速度\n钢琴之王：李斯特（匈牙利）交响思维\n《降A大调（爱之梦）》3.op.541\n卡门 序曲 比才\n舒伯特 室内音乐\n印象主义 德彪西 牧神午后前奏曲\n结束在 1 大调，6 小调\n罗西尼 《威廉退尔》序曲\n上行旋律线\n下行旋律线\n马斯涅《泰伊斯》蜿蜒曲折\n《升F大调即兴曲》 肖邦\n《乡村骑士》 《教父》间奏曲\n巴洛克时期：速度不变\n浪漫主义时期：速度和力度变化，自由速度\n《流浪者之歌》\n","date":"2021-09-28T19:34:00+08:00","permalink":"http://atksoto.com/%E8%A5%BF%E6%96%B9%E9%9F%B3%E4%B9%90%E5%8F%B2-%E6%80%BB%E8%BF%B0/","title":"西方音乐史-总述"},{"content":"BUAAOO-第四单元总结 总结本单元作业的架构设计 本单元任务为设计UML分析器，包括类图，顺序图，状态图\n第一次作业 实现类图分析\n将UML元素根据其含义分为如下层次结构\n部分元素根据需求分装为MyXXX\n \n根据逻辑层次，读入过程分为三个循环，分别处理三个层次的元素\n   循环轮次 处理元素     1 UmlClass UmlInterface UmlAssociationEnd   2 UmlOperation UmlAttribute UmlAssociation UmlGeneralization UmlInterfaceRealization   3 UmlParameter    第二次作业 实现顺序图，状态图\n将UML元素根据其含义分为如下层次结构\n部分元素根据需求分装为MyXXX\n \n根据逻辑层次，读入过程分为四个循环，分别处理四个层次的元素\n   循环轮次 处理元素     1 UmlClass UmlInterface UmlAssociationEnd UmlInteraction UmlStateMachine UmlRegion   2 UmlOperation UmlAttribute UmlAssociation UmlGeneralization UmlInterfaceRealization UmlLifeline UmlState UmlPseudostate UmlFinalState   3 UmlParameter UmlMessage UmlTransition   4 UmlEvent    第三次作业 架构同第二次。\n其他的就是一些图算法的问题了。\n总结自己在四个单元中架构设计及OO方法理解的演进    单元 理解     第一单元 面向对象的层次化设计：factor，term，poly层次结构逻辑分明，各司其职，同时又都实现某接口，递归下降的操作过程中非常符合人的直觉感受。认识到清晰的逻辑架构的重要性。   第二单元 多线程设计：多线程的加入使得程序有了更多的不确定性。线程之间的交互在逻辑需要深入理解，UML流程图的作用。   第三单元 基于JML的设计：学到了JML规格相关知识，工程化思想进一步提升   第四单元 UML：清晰且彻底的理解了面向对象层次化设计的形态和结构    总结自己在四个单元中测试理解与实践的演进    单元 理解 实践     第一单元 利用python生存复杂数据，边界数据进行测试   第二单元 需要考虑线程之间时间差异可能带来的问题，性能方面也要注意特殊情况，形式化验证   第三单元 没怎么测，错了一片，看来测试很重要   第四单元 利用工具，手动构造较为复杂的UML图，进行测试。    总结自己的课程收获 ​\t16周连续的任务（其中一周有休息）任务量确实比较大，回首自己的前三篇博客，也能看到自己泡一天图书馆写程序的影子，为BUG抓狂的夜晚，周三看结果看到“你在强测中得到0分”的悲痛心情。\n​\t每周精确到天的任务，不得不说，这是一门硬课。但重要的是确实看到了自己的在这门课上的收获有多大。这是一门实实在在能学到很多东西的课程，无论是代码风格，程序基础，性能算法，还是最重要的架构设计，我都得到了比较大的提升，在最重要的架构设计上，我深刻理解了对于复杂程序甚至是工程程序中，无论是对个人还是团队合作，面向对象思想的重要性。\n​\t前几周投入的精力更大一些，第一单元和第二单元收获颇丰，得分也比较好看，第三单元有所松懈，有幸得到了强测0分体验。这门课没有考试，却比考试周突击的课能学到更多东西。\n​\t虽然最后作为社恐和菜鸡没有在研讨课发过言，也没得到什么奖，或许最后得分比较一般，但是这门课确实是我在计算机学院到目前为止感觉上的最舒服的一门课，没有什么遗憾了。\n​\t非常感谢可爱的吴际老师一学期的辛勤教学，lyj学长前两单元架构经验的倾情分享和研讨课课程组织，还有其他助教们全程的辛勤付出！\n立足于自己的体会给课程提三个具体改进建议  建议第三单元第四单元互换时间，第三单元内容简单，适合考期时间紧张的情况下写，第四单元的工作量相对来说太大了，难顶 对于面向对象这门课，希望少一些算法考察，第三单元的CTLE现象太坑人，第四单元的图算法太多，虽然算法也是必须掌握的内容，但是在本来任务量就大的情况下，我认为重心应该只放在架构设计上 第三单元可以压缩，三次作业难度都明显低于其他单元。 第四单元的重复工作希望可以有所减少，代码量感觉有点大。 希望每个单元的三次作业的描述能标记增量部分，每次拿到大几千字的文档，好多内容都和之前一模一样，也容易看不进去 研讨课加分政策感觉有点卷了，对于我这种又比较弱又社恐的人有种被push的感觉  （超过3个了，不好意思）\n以上仅是作为一个比较弱的人的个人主观想法，可能存在发牢骚现象，如有不合理内容请无视，相信课程组多年来积累的经验，祝OO课程组越来越好！\n完结撒花！！！\n","date":"2021-06-26T11:23:00+08:00","permalink":"http://atksoto.com/buaaoo-%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/","title":"BUAAOO-第四单元总结"},{"content":"BUAAOO-第三单元总结 实现规格所采取的设计策略 在第一次作业中，开始没有经验，采取了直接对规格进行“翻译”的策略，对数据保存直接使用了定长数组，后发现这样操作代码可读性不高且性能较差，于使重新改写为使用HashMap保存。\n第二次作业中，虽然使用容器实现了数据存储，但是算法方面由于直接按照规格描述进行实现，导致了大量的CTLE。于使此后，阅读完规格后我能对方法有彻底理解后再根据自己的理解去实现。\n再有以上经验后，认为实现规格应采取如下步骤：\n 完整阅读规格 选择正确的数据结构，容器 正确处理异常 选择合适的算法实现方法  基于JML规格来设计测试的方法和策略  再次阅读JML规格，检查在方法被实现前，异常是否被正确，处理检查方法是否满足规格的ensure 使用Junit，针对每一个具一定不确定因素的方法编写测试样例进行测试 对程序整体进行大数据集测试  本单元看似简单，但在测试方面我做的并不理想，在三次作业中均出现了非常低级的BUG\n第一次：\n \n原因是在阅读JML时并未彻底理解其含义，直接按照规格进行书写，导致进行了逻辑完全错误的一个判断\n第二次：\n \n低估了自己犯低级错误的的概率（当然本次作业主要问题在CTLE上）\n第三次：\n \n自作聪明在判断异常之前就删除了message，造成了大量WA\n三次作业出现的bug基本都是在阅读JML规格时丧失理性造成的，事实证明在阅读JML时候一定要保证独立思考的能力，当然锅也不能全部甩到这里，归根结底还是自己懒得测试且高估了自己写简单代码不出错的能力。\n(Junit暴力测试？)\n@org.junit.jupiter.api.Test void sendIndirectMessage() throws EqualPersonIdException, PersonIdNotFoundException, EqualRelationException, MessageIdNotFoundException, EmojiIdNotFoundException, EqualMessageIdException, RelationNotFoundException, EqualEmojiIdException { Network network = new MyNetwork(); network.addPerson(new MyPerson(1, \u0026#34;A\u0026#34;, 10)); network.addPerson(new MyPerson(3, \u0026#34;N\u0026#34;, 10)); network.addPerson(new MyPerson(6, \u0026#34;F\u0026#34;, 10)); network.addRelation(1, 3, 10); network.addRelation(3, 6, 15); network.addRelation(1, 6, 26); network.storeEmojiId(1); network.storeEmojiId(3); network.storeEmojiId(5); network.storeEmojiId(7); network.storeEmojiId(9); network.storeEmojiId(91); network.addMessage(new MyMessage(1, 10, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(2, 1, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(3, 1, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(4, 1, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(5, 3, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(6, 9, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(7, 91, network.getPerson(1), network.getPerson(6))); network.addMessage(new MyEmojiMessage(8, 91, network.getPerson(1), network.getPerson(6))); for (int i = 0; i \u0026lt; 8; i++) { network.sendMessage(i + 1); } assertEquals(4, network.deleteColdEmoji(1)); assertEquals(true,network.containsEmojiId(91)); network.deleteColdEmoji(3); assertEquals(false,network.containsEmojiId(91)); } 容器选择和使用的经验  避免直接使用定长数组。 根据需求进行容器的选择，如果对象是通过ID来进行大部分操作，那么使用HashMap进行存储，如果对象如Person.messages，需要从头取出，从尾放入等操作，则使用ArrayList进行存储。适当的情景下也可使用Hashset来做集合的不重复性。 不确定要用什么的情况下，似乎还是用HashMap比较靠谱  性能问题 本次作业会出现的性能问题主要集中在容器的选择，qbs的算法，ageMean，ageVar等的算法。\n对于容器的问题，我的避免超时的方法是采取了适合的容器如HashMap\n我在第二次作业中大面积出现了性能问题（估计能踩的坑我都踩了）\n qbs的算法采用了规格描述的算法直接进计算，于使我对其进行了并查集算法的修改，在addPerson和delPerson的时候就对拥有同一个根节点的节点构成一个集合。（一开始还写了DFS，慢的要死就算了，还写了一堆BUG，忙一下午，服了。）  private final HashMap\u0026lt;Integer, Integer\u0026gt; parent = new HashMap\u0026lt;\u0026gt;(); private final HashMap\u0026lt;Integer, Integer\u0026gt; rank = new HashMap\u0026lt;\u0026gt;(); private int find(int id) { if (parent.get(id) != id) { parent.put(id, find(parent.get(id))); } return parent.get(id); } private void union(int id1, int id2) { int p = find(id1); int q = find(id2); if (p == q) { return; } if (rank.get(p) \u0026lt; rank.get(q)) { parent.put(p, q); } else if (rank.get(p) \u0026gt; rank.get(q)) { parent.put(q, p); } else { parent.put(p, q); rank.put(q, rank.get(q) + 1); } } ageMean，ageVar等的计算，起初我的计算直接采用了每次调用方法是从头开始计算的实现，结果导致每次计算要消耗大量的CPU超时，导致了CTLE，后改为在进行addperson的时候直接进行累加加和的操作，在询问ageMean的时候可以直接进行返回。  private int ageSum = 0; private int ageMean = 0; private int ageVar = 0; private int valueSum = 0; @Override public void addPerson(Person person) { people.put(person.getId(), person); ageSum += person.getAge(); ageMean = ageSum / people.size(); ageVar = 0; for (Person p : people.values()) { ageVar += (p.getAge() - ageMean) * (p.getAge() - ageMean); if (p.isLinked(person)) { valueSum += p.queryValue(person) * 2; } } ageVar = ageVar / people.size(); } @Override public void delPerson(Person person) { people.remove(person.getId()); if (people.isEmpty()) { initialData(); return; } ageSum -= person.getAge(); ageMean = ageSum / people.size(); ageVar = 0; for (Person p : people.values()) { ageVar += (p.getAge() - ageMean) * (p.getAge() - ageMean); if (p.isLinked(person)) { valueSum -= p.queryValue(person) * 2; } } ageVar = ageVar / people.size(); } 架构设计 除了各个对象的HashMap以外，network维护一个并查集，group维护多个基本数据，在addPerson的能操作时进行各个数据的更新。\n不知道写什么了，这单元挺搞心态的，对自己写BUG的能力又有了新的认识，因为自己时间不够能力不足，总做不好测试这一块，我也不知道怎么办，就尽力别写bug吧。不讲丧气话，这单元学到了JML规格相关知识，好像还是挺“严谨”的，如果以后工作或者什么遇到了，应该挺受益的，不过有一说一，我是不会愿意去自己写这个JML的，如果有中文版的JML能几句话讲清楚，那没准可以试试。\n","date":"2021-05-29T11:54:00+08:00","permalink":"http://atksoto.com/buaaoo-%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/","title":"BUAAOO-第三单元总结"},{"content":" 知识点纲要 \n结构\nstruct Student { int i; int j; char c; } 由于int需要占用4个字节，由于结构的空间分配是大对齐，总共需要12个空间。 当然也可以压缩空间，把它压缩为实际只使用的9个字节。\n压缩：\n#pragma pack(1) 宏 函数宏\n#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0]) 控制宏\n#define HOME //用于控制开关 #ifdef HOME cout \u0026lt;\u0026lt; \u0026#34;link a\u0026#34; \u0026lt;\u0026lt; endl; #elseif cout \u0026lt;\u0026lt; \u0026#34;link b\u0026#34; \u0026lt;\u0026lt; endl; #endif #ifdef WIN32 //windows平台上一定会有的宏 #include \u0026lt;windows.h\u0026gt;#endif 如果把C++程序和C程序混合编译\nextern \u0026#34;C\u0026#34; void fun_C(); 这个语句就是用于告诉链接器，这个函数是用C标准编译的，不要按照C++编译器修饰的方式去找。\n函数\n//1.overloading //2.default parameter //默认参数必须放后 void fun2(int a, int b = 3, int c = 4) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } //3.占位参数 void fun3(int) { cout \u0026lt;\u0026lt; 233 \u0026lt;\u0026lt; endl; } C++ 面向对象 struct Person { private: int age; char *name; public: Person(int aage, char *aname); ~Person(); }; Person::Person(int aage, char *aname) { this-\u0026gt;age = aage; this-\u0026gt;name = aname; } Person::~Person(){ //析构函数 } struct和class区别：class默认成员变量private\n默认构造：不带括号\nTest t1(3); Test *t2 = new Test(); Test t3(2,3); Test t4(); //this is a function Test t4; Test *t5 = new Test(3); 函数的原则：尽量不用返回值去返回，输入输出参数放在参数里\n成员变量原则：\nvalue：必然组成部分\naddress：可有可无的部分\n类嵌套：\nclass Point; class Circle{ Point *p; }; class Point{ Circle c; }; 析构函数(destructor)：\n对象消亡时自动调用\n可用于free堆区malloc\n防止重复free，free时：\nif (p != NULL) { free(p); p = NULL; } 指针与引用 指针的问题\n//1. fly pointer (if null / assert) //2. memory leak (free) //3. return addr of local var //4. multi-pointers for one object 引用\n//reference 引用 int m = 5; int \u0026amp;r = m; //m的小名 对象的copy\n//bitwise copy 浅拷贝（默认） vs. logical copy 深拷贝 //copy constructor Test::Test(Test \u0026amp;t) { this-\u0026gt;i = t.i; //!!!this-\u0026gt; = t.j  this-\u0026gt;j = (int *) malloc(sizeof(int)); *j = *t.j; } e\n// pass by value vs. pass by address(pointer or reference) //效果 read read/write //性能 sizeof(object) sizeof(int) //麻烦 copy-constructor nothing //conclusion: never pass by value(build-in type except) new and delete //Test *p = (Test *)malloc(sizeof (Test)); Test *p =new Test(1,2); //new = malloc + constructor delete p; //delete = destructor + free; //多个对象 Test *p = new Test[10]; //要求有默认构造 delete []p; 常量 void Test::fun() const{ //read only function }; const Test t; t.fun(); static void fun(){ static int i; //堆区，与全局变量同 } extern 全局变量不定义在头文件，定义在某一源文件中\nextern外链接放在头文件。\n函数默认extern外链接，用static修饰表明作用域为本文件。\nextern int g_i; 类中static修饰：全类的共享空间\nclass test{ static int i; int j; public: Test(int aj); } //显示一次性初始化 int Test::i = 100; static无this指针\noperator 重载运算符\n[] 重载数组 * 重载取内容 new delet 重载malloc ++重载++\nclass Account{ int id; int balance; public: Account \u0026amp;operator+(int n); //++a  Account\u0026amp; operator++(); //a++  Account operator++(int); }; Account \u0026amp;Account::operator+(int n) { this-\u0026gt;balance += n; } Account\u0026amp; Account::operator++() { this-\u0026gt;balance++; return *this; } Account Account::operator++(int) { Account old = *this; this-\u0026gt;balance++; return old; } int main() { Account a; a = a+100; } 继承(inheritance)与组成(composition) //(derived class)子类 class Student : public Borrower { public: void borrow_book(); }; void Student::borrow_book() { Borrower::borrow_book(); cout \u0026lt;\u0026lt; \u0026#34;if\u0026gt;=5 return\u0026#34; \u0026lt;\u0026lt; endl; } 注意构造顺序\n子类构造器自动调用父类构造器，析构相反\n组成也会先自动调用内部对象的构造(Engine initial - Car initial)\n//构造器初始化列表(若没有默认构造无法默认调用) Derived::Derived(int ai, int aj):Base(ai){ } //有先后顺序 Test::Test(int ai, int aj) :i(ai),j(aj){ } 多继承(菱形结构)\nclass Derived : public Base1, public Base2{} 多态  upcasting 向上转换 later binding vs. early binding polymorphism 多态性 virtual constructor \u0026amp; destructor 构造无多态，析构往往多态 abstract class (interface in Java \u0026amp; C#)  class Pet { char *name; int age; public: virtual void speak(); //虚函数 内存占用+8 子类自动virtual }; #include\u0026lt;cstdlib\u0026gt;void Needle(Pet\u0026amp; pet) //never pass by value 拷贝构造使多态失效 { //binding  //1. early binding  //2. later(dynamic/runtime) binding  pet.speak(); } 多态的实现：\n类：V-table 虚函数表\n对象：V-ptr 指向本类虚函数\n//纯虚函数 virtual void speak() = 0; //抽象类：含纯虚函数，无法创建对象 行为串联：当两个类别家族因为行为共性发生关系时，用抽象类来关联两个类别家族\ntemplate class //template class 模板类 collection in Java template\u0026lt;class T\u0026gt; class Stack { T pool[100]; int top; public: //内联函数 inline function  //top=0  Stack() : top(0) { } void push(T v) { pool[top++] = v; } T pop() { return pool[--top]; } }; int main() { Stack\u0026lt;int\u0026gt; s1; Stack\u0026lt;double\u0026gt; s2; } STL\n//STL: standard template library #include \u0026lt;vector\u0026gt; int main() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10000; ++i) { v.push_back(i); } cout \u0026lt;\u0026lt; v[9988] \u0026lt;\u0026lt; endl; } iterator\nvector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; ++i) { v.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it = v.begin(); while (it != v.end()) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; it++; } name space类上一级层次\nusing namespace my_nsp try catch 和Java一样\nassert\n//让断言全部失效 #define NDEBUG friend\n","date":"2021-04-30T11:00:00+08:00","permalink":"http://atksoto.com/c-%E5%9F%BA%E7%A1%80/","title":"C++基础"},{"content":"BUAAOO-第二单元总结 作业分析 同步块与锁 InputThread捕捉输入，将其加入waitQueue队列中\nDispatcher负责控制waitQueue，对waitQueue的操作需要经过Dispatcher\nElevator为电梯个体对象，其内包含一个requests用于表示目前位于电梯里的请求\n其中，锁全部位于调度器中\n例如\npublic PersonRequest checkTopRequest() { synchronized (waitQueue) { int max = 0; PersonRequest request = null; for (PersonRequest r : waitQueue) { if (r.getFromFloor() \u0026gt; max) { max = r.getFromFloor(); request = r; } } return request; } } 三次作业都为相同的设计，Dispatcher基本没有变动。\n调度器设计与线程交互 外部可以放心与调度器进行交互，类似生产者消费者模型，调度器维护waitQueue，输入线程通过调度器向其中加入请求，电梯通过调度器查询和获取请求\n \n第二、三次作业中加入了多个电梯与dispatcher交互\n电梯策略：\nRandom：自由竞争，直接去找队列中第一个目标，接到请求后，优先处理电梯中的第一个请求，在运行过程中在每层判断是否可以接送乘客并且进行操作。\nMorning：电梯位于1层，开始接人，2s后出发，一直送到电梯内请求列表的最高层后返回，依次循环\nNight：直接前往队列中最高层接人，向下过程中继续接人，回到一层后依次循环。\nUML 第一次作业 Main创建输入和电梯线程以及调度器，输入线程提供mode，requests，end等，调度器负责控制队列，elevator进行运行。\n \n流程图：\n \n第二次作业 相比第一次作业，输入线程负责创建新的Elevator\n \n流程图\n \n第三次作业 结构和第二次没有什么不同，在电梯类内部进行了ABC的区分，没有进行换乘的优化，仅仅是规定了各个电梯可人的层数后进行自由竞争。\n流程图\n \n分析自己程序的bug 在第一次作业没有互测bug。\n第二次作业自测的bug主要集中在没有正确结束线程。互测没有被找到bug，但是强测出现了一个超载的bug，原因在进行电梯可承载人数时加减号使用错误导致超载。\n第三次作业自测阶段的bug主要在电梯由于型号不同，理论上结束标志不一，我在while循环结束的时候仅判断了input的信号，导致部分电梯提前结束，后来又因为没有正确结束导致while死循环CPU超时。\n在互测中被hack一次，原因是我没有进行换乘优化，对方的数据点为集中的密集底层到高层数据，我的电梯只有C会去接人，导致超时。\n分析自己发现别人程序bug所采用的策略 能力有限，这几次没有对他人的程序进行bug测试\n心得体会 多线程的加入使得程序有了更多的不确定性，增加了测试的难度，但总而言之，只要做好线程的安全，如定义好线程安全类在进行操作，处理好线程的结束，不产生轮询，就可以避免多线程带来的bug。线程之间的交互在逻辑上就如同P6流水线的竞争一样，需要进行大量情况的考虑。在这几次作业中，我学会了多线程程序的正确处理。\n最终代码量\n \n","date":"2021-04-25T22:33:00+08:00","permalink":"http://atksoto.com/buaaoo-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/","title":"BUAAOO-第二单元总结"},{"content":"从早上得知巨人烂尾，心情一直阴霾，实在忍不住了，想宣泄一下。\n2013年的时候进击的巨人刚出，第一集艾伦的妈妈被吃前的那一句别抛下就给我留下了深刻的印象，那时候也不懂太多，一方面是被这样残酷的场景震慑了，一方面跟着大伙无脑燃。之后过了很多年，这期间一直也不算是巨人粉。到后来第二季莱纳贝尔托特叛变，我第一次被悲壮的氛围和史诗级的音乐震撼到，那一段我反反复复看了有几十遍，每一次看都起鸡皮疙瘩。那时候也很喜欢巨人第二季振奋的OP献出心脏，也很喜欢结尾怪诞的ED，不知道单曲循环了多少遍，那时候真的对巨人的剧情特别感兴趣，就像那个墙内的少年一样，抑制不住自己的好奇心，也看了很多漫画剧透，每天都在想巨人的剧情，好奇那只猴子，好奇所谓的故乡，被三笠对艾伦，尤弥尔对女王的爱打动。\n到后来第三季part1王政篇，这时候的我也算是有更成熟的心智了，愿意去思考所谓立场，正义云云的东西，为团长帅气的政变欢呼，为墙内之王感到悲伤，也为肯尼的世界观赞叹不已。到part2时，正值高三，夺回玛丽亚之战，团长的冲锋，爱尔敏的牺牲，兵长砍猴，带给我悲伤却震撼的复杂情绪，也正是这一个个场景让我觉得巨人在我心中永远位于神坛。高考前夕正好更新了白夜，救谁的问题让我揪心，最终的结果也如高考的结束一样让我释然。随着进入地下室揭开一切秘密。\n在我大学生活，也终于迎来了第四季的马莱篇，我对各个名场景充满期待，期待着巨人在我有生之年完成他的封神。我人生的前20个年头也这样过下来了。\n总而言之，巨人在我的人生道路上，确确实实在深刻的影响我的三观，他就像是我的另一部分一样陪着我成长，我一直尽量谨慎的不去跟别人讨论巨人，因为我想让这个我心中top1的艺术品永远被我保护起来。\n今天迎来了巨人的结局，因为我一直不看漫画，第四季前半部分结束后的剧情我全然不知，但是看到知乎都在讨论最后一话，没忍住就去看了。真的很难想象，这是出自谏山创之手，好像一下子三观全部毁掉了，母亲被吃是艾伦意料之内的，士兵们的牺牲全部成了白给，人设崩塌，立意全毁···这不是简单的烂尾，这是作者故意为之，一时间好像我从小到大的老朋友突然捅了我几刀，使劲践踏着我的尊严，难受的我说不出话。\n我就是在昨天还认为，巨人就算烂尾了也永远是我心中的神，我对巨人的感情已经超过了能客观评价的程度，他已经足够好了，但是真的没想到作者能做到这个份上，更多的批评不想说了，说的越多自己越难受，大概这就是作者的目的吧。\n我还会感谢曾经的巨人，他带着我思考了很多问题，深刻影响了我的三观，巨人与我很有缘分，他就像我的青春一样，永远停留在我人生的前20年了。\n","date":"2021-04-08T17:16:00+08:00","permalink":"http://atksoto.com/%E5%85%B3%E4%BA%8E%E5%B7%A8%E4%BA%BA%E7%9A%84%E7%83%82%E5%B0%BE/","title":"关于巨人的烂尾"},{"content":"BUAAOO-第一单元总结 基于度量分析程序结构 第一次作业 对多项式的求导，Expression类表示一个表达式，其成员变量为Term对象的hashmap，Interpreter用于解析输入字符串，返回一个Expression\n \n基于度量分析 类复杂度\n \n方法复杂度\n \n可以看到Term.toString过于复杂，原因是在幂函数转化为string类型时使用了过多的if，此处可以进行优化。\n本次作业没有被其他同学hack。性能方面，由于使用了hashmap，表达式基本上达到了最短，没有考虑到正负号打头和x**2拆分为x*x等细节\n本次作业没有很好的给下一次作业做好铺垫，表达式解析方法过于粗暴。\n第二次作业 本次作业难度骤升，因为要考虑表达式因子，第一次作业使用的暴力解析字符串方法骤然失效，遂彻底进行重构。我在本次作业中大量时间用于研究如何递归下降读取表达式。求导本身并不困难，创建Factor接口，sin，cos，幂函数，常量，term，poly均继承Factor，保证每个因子都有实现tostring和求导以及simplify方法。其中，Term是一些Factor构成的List，Poly是一些Term构成的List。在对Poly进行求导会自然向下递归。\nPatterns存放了提前编译好的正则表达式\nParser用于递归下降解析表达式\n \n类复杂度\n \n可见Parser中方法复杂度较高，这是因为在解析字符串过程中，我调用了过多的私有方法，此处可以进行模块化优化。\nTerm中由于simplify和diff的操作过于复杂，整体复杂度较高，此处可以把一些操作在初始化term时完成来优化。\n方法复杂度\n \n复杂度较高的几个方法\n \n其中Term的simplify如前文所述，该方法过于臃肿。\n第三次作业 本次作业加入了sin和cos内的嵌套已经wrong format的检测。由于和上一次作业的架构相似，仅需调整sin和cos内成员变量为Poly，并且对parser进行进一步递归下降即可。wrong format成为了难点，由于上一次作业的递归下降读取基于表达式正确的情况，这次由于格式可能的错误，我对parser进行了较大的调整，首先对字符串进行多余空白符和非法字符的判断，随后在递归下降读取过程中判断格式错误，包括括号和幂函数的错误。\n结构与第二次作业相似，加入了format checker和WF exception\n \n类复杂度\n \n方法复杂度\n \n其中较高的和第二次作业类似\n其中getCosFactor和getSinFactor是由于进行了格式的判断，此处重用了相似的代码，可以归类为一个方法进行优化。\n \n分析自己程序的bug 在前两次作业中，互测阶段没有被找到bug，在个人初期写代码过程中，遇到的一些BUG如：没有及时在while循环中continue，在if判断中逻辑过于复杂导致自己搞错了与或非逻辑，往往正是这类小的失误导致耗费大量时间debug，因此在写程序过程中应该时刻关注代码的复杂度。\n第三次作业，互测阶段被hack了两次，问题均是出在格式判断正负号和常数之间的空格时，我的判断条件出了问题，误判了一些正确的格式，自己写wrong format时没有考虑到各种情况，测试不够充分。\n对比分析出现bug的方法和未出现bug的方法在代码行和圈复杂度上的差异：在我的前两次作业中自己发生的BUG很明显主要是因为圈复杂度导致的，在第三次作业被hack的这个BUG主要是因为Wrong Format欠考虑。\n分析自己发现别人程序bug采用策略 主要采取的策略构建一些我在写代码过程中遇到的容易发生bug的数据点来对别人的代码进行测试，使用python进行核对。\n重构经历总结 第一次到第二次作业过程中经历了重构，原因是第一次作业没有留下足够的拓展空间，解析字符串过于暴力，但是在第二次作业理解了如何递归下降进行读取解析之后，重构反而显得思路更加清晰，在这个架构下，第三次作业完成的比较容易。由于重构前后属2次作业内容，没有可比较性，故未通过数据进行对比。\n吸取的教训是：尽可能给程序留下充足的可扩展空间，已经写好的类尽量保证其完备性，在拓展时就尽量不去修改了，类之间的保证解耦，方法复杂度尽可能底，如此下来可以保证程序的鲁棒性。\n心得体会 第一次作业思维还是比较偏面向过程的，对字符串进行了暴力解析，对象也仅仅停留在所谓的Term和Expression上。\n在第二次作业难度骤然增加后，明白了面向对象的重要性，一个接口下的多个类逻辑分明，调用各自的方法，另外，在第二次作业过程中，理解了递归下降的思路，这是一种逻辑非常清晰的做法，为我的第三次作业节省了大量的时间。\n第三次作业在格式判断上填了第二次作业留下的坑，更进一步理清了整个程序的逻辑，虽然最后在性能分上没有占到很多优势，但是总体下来我认为代码的结构和逻辑还是很清晰的，代码总计行数705完成了。\n总的来说，本次作业虽然遇到一些困难（指第二次作业递归下降和如何优化）但总体来说还是学到了很多东西，包括但不仅限于面向对象的思维，正则表达式的使用，Java容器操作的熟练，递归等。\n","date":"2021-03-28T19:23:00+08:00","permalink":"http://atksoto.com/buaaoo-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/","title":"BUAAOO-第一单元总结"},{"content":"Blog搭建 https://zhuanlan.zhihu.com/p/26625249\nhttps://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\n安装：npm install -g hexo\nHexo指令 基本1 hexo n \u0026quot;我的博客\u0026quot; == hexo new \u0026quot;我的博客\u0026quot; #新建文章 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署 域名解析 在github项目根目录新建一个名为CNAME的文件，里面填写域名\n然后CNAME解析\n图片 https://www.cnblogs.com/bzsheng/p/13802829.html\n  https://hexo.io/docs/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2020-12-21T23:34:37+08:00","permalink":"http://atksoto.com/hexo%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/","title":"Hexo食用方法"},{"content":"失败的规律 墨菲定律 定义 如果做某项工作有多种方法，而其中有一种方法将导致事故，那么一定有人会按这种方法去做。\n四种表现形式 （注意：都不是一定的）\n 任何事都没有表面看起来那么简单 所有的事都会比你预计的时间长 会出错的事不论概率多小总会出错 如果你担心某种情况发生，那么它就更有可能发生  启示  不忽视小概率事件 未雨绸缪 应急预案，动态调整 事故学习，反思  海因里希法则 定义 1：29：300\n事故因果连锁论 伤亡事故的发生不是一个孤立的事件，是一系列事件相继发生的结果。\n 1，事故往往起于人而又终止于人\n2，人的不安全行为是大多数工伤事故的原因\n3，人在受到伤害前，已经历数百次没有造成伤害的同类事故\n4，人受到伤害的严重程度具有随机性，大多可以避免\n5，人不安全行为的主要原因是不正确的态度\n 启示 企业安全工作的中心就是防止人的不安全行为，消除机械的或物质的不安全状态，中断事故连锁的进程而避免事故的发生。\n浴盆曲线 可靠性：完成规定功能的能力\n可靠度：完成规定功能的概率\n可靠度 MTBF\n不可靠度 MTTF\n故障率 浴盆曲线\n失败的分析 失败分析三种方式 模式 FMECA 故障模式影响及危害性分析\n原因 FTA 故障树\n事件 ETA 事件树\n失败风险 两个要素：失败的概率和后果\n技术，费用，进度风险\n风险识别，风险分析（可能性，后果严重性），风险排序\n管理，评估，应对\n失败的预防 优生优育  优质材料 降额\\裕度设计 余度设计 健壮设计 耐环境设计 放错设计  养生保健  熟练的使用 定期的维护 有力的保障 持续的改进  失败的思维 如何看待失败 知识管理的概念 从失败中学习：知识的螺旋 吃一堑长一智：失败知识从哪来 失败知识的共享 失败知识的应用\n如何看待成功 发明的等级 技术的进化 矛盾的冲突 创新的原理 案例的分析\n系统思维 系统工程方法：霍尔方法论\n系统定义与特性：\n系统是由相互作用和相互依赖的若干组成部分结合成的、具有特定功能的有机整体。\n6个特点\n系统思维的感性认识\n","date":"2020-10-29T11:54:00+08:00","permalink":"http://atksoto.com/%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","title":"失败的逻辑课程笔记"}]