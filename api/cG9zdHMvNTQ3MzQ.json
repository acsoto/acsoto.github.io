{"title":"BUAAOO-第二单元总结","date":"2021-04-25T14:33:00.000Z","date_formatted":{"ll":"2021年4月25日","L":"2021/04/25","MM-DD":"04-25"},"link":"posts/54734","tags":["BUAA","面向对象"],"updated":"2021-12-01T08:28:48.586Z","content":"<h1 id=\"buaaoo-第二单元总结\">BUAAOO-第二单元总结<a title=\"#buaaoo-第二单元总结\" href=\"#buaaoo-第二单元总结\"></a></h1>\n<h2 id=\"作业分析\">作业分析<a title=\"#作业分析\" href=\"#作业分析\"></a></h2>\n<h3 id=\"同步块与锁\">同步块与锁<a title=\"#同步块与锁\" href=\"#同步块与锁\"></a></h3>\n<p>InputThread捕捉输入，将其加入waitQueue队列中</p>\n<p>Dispatcher负责控制waitQueue，对waitQueue的操作需要经过Dispatcher</p>\n<p>Elevator为电梯个体对象，其内包含一个requests用于表示目前位于电梯里的请求</p>\n<p>其中，锁全部位于调度器中</p>\n<p>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PersonRequest <span class=\"title\">checkTopRequest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (waitQueue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        PersonRequest request = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (PersonRequest r : waitQueue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.getFromFloor() &gt; max) &#123;</span><br><span class=\"line\">                max = r.getFromFloor();</span><br><span class=\"line\">                request = r;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>三次作业都为相同的设计，Dispatcher基本没有变动。</p>\n<h3 id=\"调度器设计与线程交互\">调度器设计与线程交互<a title=\"#调度器设计与线程交互\" href=\"#调度器设计与线程交互\"></a></h3>\n<p>外部可以放心与调度器进行交互，类似生产者消费者模型，调度器维护waitQueue，输入线程通过调度器向其中加入请求，电梯通过调度器查询和获取请求</p>\n<p><img src=\"/posts/54734/image-20210425163631337.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>第二、三次作业中加入了多个电梯与dispatcher交互</p>\n<p>电梯策略：</p>\n<p>Random：自由竞争，直接去找队列中第一个目标，接到请求后，优先处理电梯中的第一个请求，在运行过程中在每层判断是否可以接送乘客并且进行操作。</p>\n<p>Morning：电梯位于1层，开始接人，2s后出发，一直送到电梯内请求列表的最高层后返回，依次循环</p>\n<p>Night：直接前往队列中最高层接人，向下过程中继续接人，回到一层后依次循环。</p>\n<h3 id=\"uml\">UML<a title=\"#uml\" href=\"#uml\"></a></h3>\n<h5 id=\"第一次作业\">第一次作业<a title=\"#第一次作业\" href=\"#第一次作业\"></a></h5>\n<p>Main创建输入和电梯线程以及调度器，输入线程提供mode，requests，end等，调度器负责控制队列，elevator进行运行。</p>\n<p><img src=\"/posts/54734/image-20210425171756534.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>流程图：</p>\n<p><img src=\"/posts/54734/image-20210425214505979.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"第二次作业\">第二次作业<a title=\"#第二次作业\" href=\"#第二次作业\"></a></h5>\n<p>相比第一次作业，输入线程负责创建新的Elevator</p>\n<p><img src=\"/posts/54734/image-20210425215005256.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<p>流程图</p>\n<p><img src=\"/posts/54734/image-20210425215341767.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"第三次作业\">第三次作业<a title=\"#第三次作业\" href=\"#第三次作业\"></a></h5>\n<p>结构和第二次没有什么不同，在电梯类内部进行了ABC的区分，没有进行换乘的优化，仅仅是规定了各个电梯可人的层数后进行自由竞争。</p>\n<p>流程图</p>\n<p><img src=\"/posts/54734/image-20210425220331346.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"分析自己程序的bug\">分析自己程序的bug<a title=\"#分析自己程序的bug\" href=\"#分析自己程序的bug\"></a></h3>\n<p>在第一次作业没有互测bug。</p>\n<p>第二次作业自测的bug主要集中在没有正确结束线程。互测没有被找到bug，但是强测出现了一个超载的bug，原因在进行电梯可承载人数时加减号使用错误导致超载。</p>\n<p>第三次作业自测阶段的bug主要在电梯由于型号不同，理论上结束标志不一，我在while循环结束的时候仅判断了input的信号，导致部分电梯提前结束，后来又因为没有正确结束导致while死循环CPU超时。</p>\n<p>在互测中被hack一次，原因是我没有进行换乘优化，对方的数据点为集中的密集底层到高层数据，我的电梯只有C会去接人，导致超时。</p>\n<h3 id=\"分析自己发现别人程序bug所采用的策略\">分析自己发现别人程序bug所采用的策略<a title=\"#分析自己发现别人程序bug所采用的策略\" href=\"#分析自己发现别人程序bug所采用的策略\"></a></h3>\n<p>能力有限，这几次没有对他人的程序进行bug测试</p>\n<h3 id=\"心得体会\">心得体会<a title=\"#心得体会\" href=\"#心得体会\"></a></h3>\n<p>多线程的加入使得程序有了更多的不确定性，增加了测试的难度，但总而言之，只要做好线程的安全，如定义好线程安全类在进行操作，处理好线程的结束，不产生轮询，就可以避免多线程带来的bug。线程之间的交互在逻辑上就如同P6流水线的竞争一样，需要进行大量情况的考虑。在这几次作业中，我学会了多线程程序的正确处理。</p>\n<p>最终代码量</p>\n<p><img src=\"/posts/54734/image-20210425225410022.png\" alt loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"C++基础","link":"posts/44178"},"next":{"title":"BUAAOO-第一单元总结","link":"posts/56284"},"plink":"http://atksoto.com/posts/54734/","toc":[{"id":"buaaoo-第二单元总结","title":"BUAAOO-第二单元总结","index":"1","children":[{"id":"作业分析","title":"作业分析","index":"1.1","children":[{"id":"同步块与锁","title":"同步块与锁","index":"1.1.1"},{"id":"调度器设计与线程交互","title":"调度器设计与线程交互","index":"1.1.2"},{"id":"uml","title":"UML","index":"1.1.3"},{"id":"分析自己程序的bug","title":"分析自己程序的bug","index":"1.1.4"},{"id":"分析自己发现别人程序bug所采用的策略","title":"分析自己发现别人程序bug所采用的策略","index":"1.1.5"},{"id":"心得体会","title":"心得体会","index":"1.1.6"}]}]}],"reading_time":"937 字约 6 分钟"}